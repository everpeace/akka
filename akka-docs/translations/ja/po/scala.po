# Japanese translations for Akka package.
# Copyright (C) 2011, Typesafe Inc
# This file is distributed under the same license as the Akka package.
# Rikiya Yamamoto <rkyymmt@gmail.com>, 2012.
#
msgid ""
msgstr ""
"Project-Id-Version: Akka 2.0-SNAPSHOT\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2012-04-10 21:41\n"
"PO-Revision-Date: 2012-04-18 18:37+0900\n"
"Last-Translator: Rikiya Yamamoto <rkyymmt@gmail.com>\n"
"Language-Team: Japanese\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

# 9f035c4088aa4355b37ecfe2d917ab94
#: ../../scala/actors.rst:6
msgid "Actors (Scala)"
msgstr "アクタ (Scala)"

# 4b2357b0dcbe42c28a65079400494d13
#: ../../scala/actors.rst:9
msgid ""
"The `Actor Model`_ provides a higher level of abstraction for writing "
"concurrent and distributed systems. It alleviates the developer from having "
"to deal with explicit locking and thread management, making it easier to "
"write correct concurrent and parallel systems. Actors were defined in the "
"1973 paper by Carl Hewitt but have been popularized by the Erlang language, "
"and used for example at Ericsson with great success to build highly "
"concurrent and reliable telecom systems."
msgstr ""

# 37536a1e87894f89a11317b7c45b8326
#: ../../scala/actors.rst:17
msgid ""
"The API of Akka’s Actors is similar to Scala Actors which has borrowed some "
"of its syntax from Erlang."
msgstr ""
"AkkaのアクタAPIは、Erlangから借りてきた文法であるScalaアクタに似ています。"


# 1d2dc1c631da4591bef42d780b5b4c93
#: ../../scala/actors.rst:24
msgid "Creating Actors"
msgstr "アクタの生成"

# 8ae11468f4e945608c965fed1f2b1a0f
#: ../../scala/actors.rst:26
msgid ""
"Since Akka enforces parental supervision every actor is supervised and "
"(potentially) the supervisor of its children; it is advisable that you "
"familiarize yourself with :ref:`actor-systems` and :ref:`supervision` and it "
"may also help to read :ref:`actorOf-vs-actorFor`."
msgstr ""

# cd94c07b7ae74e52ba245db98ef36962
#: ../../scala/actors.rst:32
msgid "Defining an Actor class"
msgstr "アクタクラスの定義"

# 5efd9cc74033462c8d86cae3c41c0646
#: ../../scala/actors.rst:34
msgid ""
"Actor classes are implemented by extending the Actor class and implementing "
"the :meth:`receive` method. The :meth:`receive` method should define a "
"series of case statements (which has the type ``PartialFunction[Any, Unit]"
"``) that defines which messages your Actor can handle, using standard Scala "
"pattern matching, along with the implementation of how the messages should "
"be processed."
msgstr ""

# c4c1c4c90ab9476a9665192851ec7e80
# 5e6aed471ec74a2ab5d05552c6229fcf
# a03173b4fc3142c496c513a85b34689b
#: ../../scala/actors.rst:40 ../../scala/actors.rst:97
#: ../../scala/actors.rst:308
msgid "Here is an example:"
msgstr "ここで１つの例を示します："

# 85dd9e6dc32b4079bdfa1157414ec207
#: ../../scala/actors.rst:45
msgid ""
"Please note that the Akka Actor ``receive`` message loop is exhaustive, "
"which is different compared to Erlang and Scala Actors. This means that you "
"need to provide a pattern match for all messages that it can accept and if "
"you want to be able to handle unknown messages then you need to have a "
"default case as in the example above. Otherwise an ``akka.actor."
"UnhandledMessage(message, sender, recipient)`` will be published to the "
"``ActorSystem``'s ``EventStream``."
msgstr ""

# 1cf6a95024f149d2ac9bcdfea019a7ef
#: ../../scala/actors.rst:53
msgid "Creating Actors with default constructor"
msgstr "デフォルトコンストラクタでアクタを生成する"

# ee9411d5ca9f49cb9abaee5af48a5de1
#: ../../scala/actors.rst:58
msgid ""
"The call to :meth:`actorOf` returns an instance of ``ActorRef``. This is a "
"handle to the ``Actor`` instance which you can use to interact with the "
"``Actor``. The ``ActorRef`` is immutable and has a one to one relationship "
"with the Actor it represents. The ``ActorRef`` is also serializable and "
"network-aware. This means that you can serialize it, send it over the wire "
"and use it on a remote host and it will still be representing the same Actor "
"on the original node, across the network."
msgstr ""

# 25e17831dc3c43efb24c8a92ef10f21c
#: ../../scala/actors.rst:66
msgid ""
"In the above example the actor was created from the system. It is also "
"possible to create actors from other actors with the actor ``context``. The "
"difference is how the supervisor hierarchy is arranged. When using the "
"context the current actor will be supervisor of the created child actor. "
"When using the system it will be a top level actor, that is supervised by "
"the system (internal guardian actor)."
msgstr ""

# 977774acc2b24ade811cc9a7e5cfb920
#: ../../scala/actors.rst:74
msgid ""
"The name parameter is optional, but you should preferably name your actors, "
"since that is used in log messages and for identifying actors. The name must "
"not be empty or start with ``$``. If the given name is already in use by "
"another child to the same parent actor an `InvalidActorNameException` is "
"thrown."
msgstr ""

# b327bd42ff224c388949cbd95d2b608a
#: ../../scala/actors.rst:79
msgid ""
"Actors are automatically started asynchronously when created. When you "
"create the ``Actor`` then it will automatically call the ``preStart`` "
"callback method on the ``Actor`` trait. This is an excellent place to add "
"initialization code for the actor."
msgstr ""

# 6d6bf26bf8af425db590d7fd21bbffca
#: ../../scala/actors.rst:91
msgid "Creating Actors with non-default constructor"
msgstr "デフォルトでないコンストラクタでアクタを生成する"

# 43d7b61d1db04e409a64fbf1d089d488
#: ../../scala/actors.rst:93
msgid ""
"If your Actor has a constructor that takes parameters then you can't create "
"it using ``actorOf(Props[TYPE])``. Instead you can use a variant of "
"``actorOf`` that takes a call-by-name block in which you can create the "
"Actor in any way you like."
msgstr ""

# 15f17af9ae6e4fa2a6730e0b1cb6695e
#: ../../scala/actors.rst:103
msgid "Props"
msgstr "Props"

# 0ecb3e00fab84356b787b4bc6d2ffc3d
#: ../../scala/actors.rst:105
msgid ""
"``Props`` is a configuration class to specify options for the creation of "
"actors. Here are some examples on how to create a ``Props`` instance."
msgstr ""

# 2051f493fa3c46c99856b1a8e673b6c1
#: ../../scala/actors.rst:112
msgid "Creating Actors with Props"
msgstr "Propsでアクタを生成する"

# b67b315bdbfa49c4bfbd94f7637c542c
#: ../../scala/actors.rst:114
msgid ""
"Actors are created by passing in a ``Props`` instance into the ``actorOf`` "
"factory method."
msgstr ""

# 2301a190a14342758f61535d766bfae7
#: ../../scala/actors.rst:120
msgid "Creating Actors using anonymous classes"
msgstr "匿名クラスを使ってアクタを生成する"

# 979bd07c0b534dddbc957273b954e5a7
#: ../../scala/actors.rst:122
msgid ""
"When spawning actors for specific sub-tasks from within an actor, it may be "
"convenient to include the code to be executed directly in place, using an "
"anonymous class."
msgstr ""

# c8470499b9c54dcd9fba45da68905730
#: ../../scala/actors.rst:128
msgid ""
"In this case you need to carefully avoid closing over the containing actor’s "
"reference, i.e. do not call methods on the enclosing actor from within the "
"anonymous Actor class. This would break the actor encapsulation and may "
"introduce synchronization bugs and race conditions because the other actor’s "
"code will be scheduled concurrently to the enclosing actor. Unfortunately "
"there is not yet a way to detect these illegal accesses at compile time. See "
"also: :ref:`jmm-shared-state`"
msgstr ""

# a39ffcb320684dc385fd8e6fec155865
#: ../../scala/actors.rst:138
msgid "Actor API"
msgstr "アクタAPI"

# 9aa54f87981a4ab9aad78cc238fbf3d8
#: ../../scala/actors.rst:140
msgid ""
"The :class:`Actor` trait defines only one abstract method, the above "
"mentioned :meth:`receive`, which implements the behavior of the actor."
msgstr ""

# a24096d82b874a89bc9575944b86c067
#: ../../scala/actors.rst:143
msgid ""
"If the current actor behavior does not match a received message, :meth:"
"`unhandled` is called, which by default publishes an ``akka.actor."
"UnhandledMessage(message, sender, recipient)`` on the actor system’s event "
"stream."
msgstr ""

# 75333c5a31e441cda9b1089254c40eed
#: ../../scala/actors.rst:148
msgid "In addition, it offers:"
msgstr "さらに次のものを提供しています："

# a995fb4f0d30454d9a5a0390e10f3816
#: ../../scala/actors.rst:150
msgid ":obj:`self` reference to the :class:`ActorRef` of the actor"
msgstr ""

# 7e964728b58e4bbe9d077c48356262f0
#: ../../scala/actors.rst:151
msgid ""
":obj:`sender` reference sender Actor of the last received message, typically "
"used as described in :ref:`Actor.Reply`"
msgstr ""

# 2a9012a6f1b44c7aa7cda4e7591212b5
#: ../../scala/actors.rst:152
msgid ""
":obj:`supervisorStrategy` user overridable definition the strategy to use "
"for supervising child actors"
msgstr ""

# 2184088c0ae34ff4968c15f799f6d36d
#: ../../scala/actors.rst:153
msgid ""
":obj:`context` exposes contextual information for the actor and the current "
"message, such as:"
msgstr ""

# 80c77f9338ff4949af202c7150fc1f53
#: ../../scala/actors.rst:155
msgid "factory methods to create child actors (:meth:`actorOf`)"
msgstr ""

# 00a5b35323f14f399ccbd1de085c6ea2
#: ../../scala/actors.rst:156
msgid "system that the actor belongs to"
msgstr ""

# 0b0969d0c7244eb9848fb9ec965988cc
#: ../../scala/actors.rst:157
msgid "parent supervisor"
msgstr "親の管理者"

# 72f128175f92430695df4308a57715ef
#: ../../scala/actors.rst:158
msgid "supervised children"
msgstr "管理されている子供"

# 83e4613aadae42df919e824049d69826
#: ../../scala/actors.rst:159
msgid "lifecycle monitoring"
msgstr "ライフサイクルの監視"

# 35ceae97b5444daab9cfe59f7a2603f1
#: ../../scala/actors.rst:160
msgid "hotswap behavior stack as described in :ref:`Actor.HotSwap`"
msgstr ""

# 67d757ec76884bbfa1e6fd152ce3aecf
#: ../../scala/actors.rst:162
msgid ""
"You can import the members in the :obj:`context` to avoid prefixing access "
"with ``context.``"
msgstr ""

# cabb2963600a4c979f0f07cad135710b
#: ../../scala/actors.rst:166
msgid ""
"The remaining visible methods are user-overridable life-cycle hooks which "
"are described in the following::"
msgstr ""

# 5e7b2af108854cd58870389dce210813
#: ../../scala/actors.rst:177
msgid ""
"The implementations shown above are the defaults provided by the :class:"
"`Actor` trait."
msgstr ""

# d59710bb7dc94f089a33e7e95e68ba13
#: ../../scala/actors.rst:183
msgid "Lifecycle Monitoring aka DeathWatch"
msgstr "ライフサイクル監視、つまり死活監視"

# 7d9c035b463345e883948e295bd6009d
#: ../../scala/actors.rst:185
msgid ""
"In order to be notified when another actor terminates (i.e. stops "
"permanently, not temporary failure and restart), an actor may register "
"itself for reception of the :class:`Terminated` message dispatched by the "
"other actor upon termination (see `Stopping Actors`_). This service is "
"provided by the :class:`DeathWatch` component of the actor system."
msgstr ""

# 12b74a0de76f441aac8cc10fa1d57477
#: ../../scala/actors.rst:191
msgid "Registering a monitor is easy:"
msgstr "監視を登録するのは簡単です："

# 907373904ae440e6b49c3adad72f56ed
#: ../../scala/actors.rst:195
msgid ""
"It should be noted that the :class:`Terminated` message is generated "
"independent of the order in which registration and termination occur. "
"Registering multiple times does not necessarily lead to multiple messages "
"being generated, but there is no guarantee that only exactly one such "
"message is received: if termination of the watched actor has generated and "
"queued the message, and another registration is done before this message has "
"been processed, then a second message will be queued, because registering "
"for monitoring of an already terminated actor leads to the immediate "
"generation of the :class:`Terminated` message."
msgstr ""

# 049e22a9ef654efe8e38a87e4303040a
#: ../../scala/actors.rst:205
msgid ""
"It is also possible to deregister from watching another actor’s liveliness "
"using ``context.unwatch(target)``, but obviously this cannot guarantee non-"
"reception of the :class:`Terminated` message because that may already have "
"been queued."
msgstr ""

# 540633f997294384bc2fc64120cb188a
#: ../../scala/actors.rst:211
msgid "Start Hook"
msgstr "フックの起動"

# 1c23e596b6334667a4358f919a5852fc
#: ../../scala/actors.rst:213
msgid "Right after starting the actor, its :meth:`preStart` method is invoked."
msgstr ""

# a85db11e1b81478d847870ef6e078923
#: ../../scala/actors.rst:224
msgid "Restart Hooks"
msgstr "フックを再起動"

# e117ed151dd44d089f9d802195983e6a
#: ../../scala/actors.rst:226
msgid ""
"All actors are supervised, i.e. linked to another actor with a fault "
"handling strategy. Actors will be restarted in case an exception is thrown "
"while processing a message. This restart involves the hooks mentioned above:"
msgstr ""

# baf83301ab684b07a0c9067d7de260a1
#: ../../scala/actors.rst:230
msgid ""
"The old actor is informed by calling :meth:`preRestart` with the exception "
"which caused the restart and the message which triggered that exception; the "
"latter may be ``None`` if the restart was not caused by processing a "
"message, e.g. when a supervisor does not trap the exception and is restarted "
"in turn by its supervisor. This method is the best place for cleaning up, "
"preparing hand-over to the fresh actor instance, etc. By default it stops "
"all children and calls :meth:`postStop`."
msgstr ""

# e27092e938f34f52a166d66b2d743c9f
#: ../../scala/actors.rst:237
msgid ""
"The initial factory from the ``actorOf`` call is used to produce the fresh "
"instance."
msgstr ""

# 42893ad315f54ac9b3b1e1c5f3c32860
#: ../../scala/actors.rst:239
msgid ""
"The new actor’s :meth:`postRestart` method is invoked with the exception "
"which caused the restart. By default the :meth:`preStart` is called, just as "
"in the normal start-up case."
msgstr ""

# 973f0601fc874aa4b3599e73780486aa
#: ../../scala/actors.rst:244
msgid ""
"An actor restart replaces only the actual actor object; the contents of the "
"mailbox is unaffected by the restart, so processing of messages will resume "
"after the :meth:`postRestart` hook returns. The message that triggered the "
"exception will not be received again. Any message sent to an actor while it "
"is being restarted will be queued to its mailbox as usual."
msgstr ""

# 7fb64e135d4c426286868a7456dd0279
#: ../../scala/actors.rst:252
msgid "Stop Hook"
msgstr "フックの停止"

# 97a0463421b2416591ba1df2b8ffd472
#: ../../scala/actors.rst:254
msgid ""
"After stopping an actor, its :meth:`postStop` hook is called, which may be "
"used e.g. for deregistering this actor from other services. This hook is "
"guaranteed to run after message queuing has been disabled for this actor, i."
"e. messages sent to a stopped actor will be redirected to the :obj:"
"`deadLetters` of the :obj:`ActorSystem`."
msgstr ""

# 49acf049555b4582a44da178516195a4
#: ../../scala/actors.rst:261
msgid "Identifying Actors"
msgstr "アクタの識別"

# c9c8998999a44c8780055636c87547c0
#: ../../scala/actors.rst:263
msgid ""
"As described in :ref:`addressing`, each actor has a unique logical path, "
"which is obtained by following the chain of actors from child to parent "
"until reaching the root of the actor system, and it has a physical path, "
"which may differ if the supervision chain includes any remote supervisors. "
"These paths are used by the system to look up actors, e.g. when a remote "
"message is received and the recipient is searched, but they are also useful "
"more directly: actors may look up other actors by specifying absolute or "
"relative paths—logical or physical—and receive back an :class:`ActorRef` "
"with the result::"
msgstr ""

# cf0d4d8a7efc47bea292055e83613576
#: ../../scala/actors.rst:276
msgid ""
"The supplied path is parsed as a :class:`java.net.URI`, which basically "
"means that it is split on ``/`` into path elements. If the path starts with "
"``/``, it is absolute and the look-up starts at the root guardian (which is "
"the parent of ``\"/user\"``); otherwise it starts at the current actor. If a "
"path element equals ``..``, the look-up will take a step “up” towards the "
"supervisor of the currently traversed actor, otherwise it will step “down” "
"to the named child. It should be noted that the ``..`` in actor paths here "
"always means the logical structure, i.e. the supervisor."
msgstr ""

# b695af9463c54716bf3757f495d94a80
#: ../../scala/actors.rst:285
msgid ""
"If the path being looked up does not exist, a special actor reference is "
"returned which behaves like the actor system’s dead letter queue but retains "
"its identity (i.e. the path which was looked up)."
msgstr ""

# 7e43a1084398455da218c47d1165b7b1
#: ../../scala/actors.rst:289
msgid "Remote actor addresses may also be looked up, if remoting is enabled::"
msgstr "リモートアクタのアドレスは、もしリモートが可能であれば見つかるでしょう。"

# f392c6f3e1f547fb8f7e724969ab9de4
#: ../../scala/actors.rst:293
msgid ""
"These look-ups return a (possibly remote) actor reference immediately, so "
"you will have to send to it and await a reply in order to verify that "
"``serviceB`` is actually reachable and running. An example demonstrating "
"actor look-up is given in :ref:`remote-lookup-sample-scala`."
msgstr ""

# 67b885969ecb450f8c3bba7377078ec3
# 6a39579d5ad947438309162cfe876da6
#: ../../scala/actors.rst:299 ../../scala/typed-actors.rst:108
msgid "Messages and immutability"
msgstr ""

# 65d010862c3442f5bfe906678a4393ce
#: ../../scala/actors.rst:301
msgid ""
"**IMPORTANT**: Messages can be any kind of object but have to be immutable. "
"Scala can’t enforce immutability (yet) so this has to be by convention. "
"Primitives like String, Int, Boolean are always immutable. Apart from these "
"the recommended approach is to use Scala case classes which are immutable "
"(if you don’t explicitly expose the state) and works great with pattern "
"matching at the receiver side."
msgstr ""

# 6e9f3c81e0d346db9eab8f90915dceba
#: ../../scala/actors.rst:318
msgid ""
"Other good messages types are ``scala.Tuple2``, ``scala.List``, ``scala."
"Map`` which are all immutable and great for pattern matching."
msgstr ""

# e19c1fee0fbb4b358cc3390a2ee50c8e
#: ../../scala/actors.rst:323
msgid "Send messages"
msgstr "メッセージの送信"

# c8ebb6587c0a4468bd29401214e93ea8
#: ../../scala/actors.rst:325
msgid "Messages are sent to an Actor through one of the following methods."
msgstr "メッセージは次のメソッドを通じてアクタへ送信されます。"

# ef7d00774aaf462fbfe8db079734bb26
#: ../../scala/actors.rst:327
msgid ""
"``!`` means “fire-and-forget”, e.g. send a message asynchronously and return "
"immediately. Also known as ``tell``."
msgstr "``!`` は“実行し忘れる”、すなわち、メッセージを非同期で送信し即返ってくるということです。 ``tell`` とも言います。"

# 3921c0042511493aba210d0b41358eb5
#: ../../scala/actors.rst:329
msgid ""
"``?`` sends a message asynchronously and returns a :class:`Future` "
"representing a possible reply. Also known as ``ask``."
msgstr ""

# 44678ff881e941c5a5bd2dd01ba058e7
#: ../../scala/actors.rst:332
msgid "Message ordering is guaranteed on a per-sender basis."
msgstr ""

# 368c60425520484cae8bcd42ffbfbe56
#: ../../scala/actors.rst:335
msgid "Tell: Fire-forget"
msgstr ""

# b382c2973d254219b59d96e2a0e3c414
#: ../../scala/actors.rst:337
msgid ""
"This is the preferred way of sending messages. No blocking waiting for a "
"message. This gives the best concurrency and scalability characteristics."
msgstr ""

# db5e3e80b51f4824929b5f68583965e7
#: ../../scala/actors.rst:344
msgid ""
"If invoked from within an Actor, then the sending actor reference will be "
"implicitly passed along with the message and available to the receiving "
"Actor in its ``sender: ActorRef`` member field. The target actor can use "
"this to reply to the original sender, by using ``sender ! replyMsg``."
msgstr ""

# 17a2e748760e499fb91759977b92e83e
#: ../../scala/actors.rst:349
msgid ""
"If invoked from an instance that is **not** an Actor the sender will be :obj:"
"`deadLetters` actor reference by default."
msgstr ""

# 844caba7bc3d408aa7c4e18e42e56165
#: ../../scala/actors.rst:353
msgid "Ask: Send-And-Receive-Future"
msgstr ""

# 43c9de282d1b42f58e816bb4813e1d40
#: ../../scala/actors.rst:355
msgid ""
"The ``ask`` pattern involves actors as well as futures, hence it is offered "
"as a use pattern rather than a method on :class:`ActorRef`:"
msgstr ""

# ee9e20b5a01c40739657c2acddd69ea9
#: ../../scala/actors.rst:360
msgid ""
"This example demonstrates ``ask`` together with the ``pipeTo`` pattern on "
"futures, because this is likely to be a common combination. Please note that "
"all of the above is completely non-blocking and asynchronous: ``ask`` "
"produces a :class:`Future`, three of which are composed into a new future "
"using the for-comprehension and then ``pipeTo`` installs an ``onComplete``-"
"handler on the future to effect the submission of the aggregated :class:"
"`Result` to another actor."
msgstr ""

# 02a7cefedccf4105a79ff5f23bf248e6
#: ../../scala/actors.rst:368
msgid ""
"Using ``ask`` will send a message to the receiving Actor as with ``tell``, "
"and the receiving actor must reply with ``sender ! reply`` in order to "
"complete the returned :class:`Future` with a value. The ``ask`` operation "
"involves creating an internal actor for handling this reply, which needs to "
"have a timeout after which it is destroyed in order not to leak resources; "
"see more below."
msgstr ""

# 77b74069f2744208a5d07f36327ccaa2
#: ../../scala/actors.rst:374
msgid ""
"To complete the future with an exception you need send a Failure message to "
"the sender. This is *not done automatically* when an actor throws an "
"exception while processing a message."
msgstr ""

# cee55bbc4019438f8e248ad9b4343619
#: ../../scala/actors.rst:380
msgid ""
"If the actor does not complete the future, it will expire after the timeout "
"period, completing it with an :class:`AskTimeoutException`.  The timeout is "
"taken from one of the following locations in order of precedence:"
msgstr ""

# bb1b0ee7ee23413b8a8110ae31915c5b
#: ../../scala/actors.rst:384
msgid "explicitly given timeout as in:"
msgstr ""

# 6d3bfca2d45b48f48cd2bace2cb7c313
#: ../../scala/actors.rst:388
msgid "implicit argument of type :class:`akka.util.Timeout`, e.g."
msgstr ""

# f1cc1695417b4444b6111a3888698e39
#: ../../scala/actors.rst:392
msgid ""
"See :ref:`futures-scala` for more information on how to await or query a "
"future."
msgstr ""

# f2be6b56135240218d9cf8e24f743197
#: ../../scala/actors.rst:395
msgid ""
"The ``onComplete``, ``onResult``, or ``onTimeout`` methods of the ``Future`` "
"can be used to register a callback to get a notification when the Future "
"completes. Gives you a way to avoid blocking."
msgstr ""

# b220a07d4f8046fb98f8492e509afdd7
#: ../../scala/actors.rst:401
msgid ""
"When using future callbacks, such as ``onComplete``, ``onSuccess``, and "
"``onFailure``, inside actors you need to carefully avoid closing over the "
"containing actor’s reference, i.e. do not call methods or access mutable "
"state on the enclosing actor from within the callback. This would break the "
"actor encapsulation and may introduce synchronization bugs and race "
"conditions because the callback will be scheduled concurrently to the "
"enclosing actor. Unfortunately there is not yet a way to detect these "
"illegal accesses at compile time. See also: :ref:`jmm-shared-state`"
msgstr ""

# 3c1f293d1bb34ab194cd176f21e6e81b
#: ../../scala/actors.rst:411
msgid "Forward message"
msgstr ""

# d38b6e586f6544e3a8ebb885109f58c5
#: ../../scala/actors.rst:413
msgid ""
"You can forward a message from one actor to another. This means that the "
"original sender address/reference is maintained even though the message is "
"going through a 'mediator'. This can be useful when writing actors that work "
"as routers, load-balancers, replicators etc."
msgstr ""

# 45750caebf714e9c9a2ecd1ec0b8b38c
#: ../../scala/actors.rst:424
msgid "Receive messages"
msgstr ""

# 0bb9874da86c41b798d52e10c21ceee0
#: ../../scala/actors.rst:426
msgid "An Actor has to implement the ``receive`` method to receive messages:"
msgstr ""

# e20a8b33783b46108feb52688a33dfe4
#: ../../scala/actors.rst:432
msgid ""
"Note: Akka has an alias to the ``PartialFunction[Any, Unit]`` type called "
"``Receive`` (``akka.actor.Actor.Receive``), so you can use this type instead "
"for clarity. But most often you don't need to spell it out."
msgstr ""

# 6ff65876ed4b44f98f9cca50b695518f
#: ../../scala/actors.rst:436
msgid ""
"This method should return a ``PartialFunction``, e.g. a ‘match/case’ clause "
"in which the message can be matched against the different case clauses using "
"Scala pattern matching. Here is an example:"
msgstr ""

# 27de8ea6eef147a6a833beba75b4b445
#: ../../scala/actors.rst:447
msgid "Reply to messages"
msgstr "メッセージへ返答する"

# b71a1aa1bc094119bfabe3fd9fc72f52
#: ../../scala/actors.rst:449
msgid ""
"If you want to have a handle for replying to a message, you can use "
"``sender``, which gives you an ActorRef. You can reply by sending to that "
"ActorRef with ``sender ! replyMsg``. You can also store the ActorRef for "
"replying later, or passing on to other actors. If there is no sender (a "
"message was sent without an actor or future context) then the sender "
"defaults to a 'dead-letter' actor ref."
msgstr ""

# 67a3778d72c44e2cb41e0d76923dc012
#: ../../scala/actors.rst:463
msgid "Initial receive timeout"
msgstr ""

# 5eb094071690455e98454a8335906c3e
#: ../../scala/actors.rst:465
msgid ""
"A timeout mechanism can be used to receive a message when no initial message "
"is received within a certain time. To receive this timeout you have to set "
"the ``receiveTimeout`` property and declare a case handing the "
"ReceiveTimeout object."
msgstr ""

# 03846ba0a5194d62a08c9b6b16db52a1
#: ../../scala/actors.rst:475
msgid "Stopping actors"
msgstr ""

# 1231331d70b94f378622b3d646be9b8b
#: ../../scala/actors.rst:477
msgid ""
"Actors are stopped by invoking the :meth:`stop` method of a "
"``ActorRefFactory``, i.e. ``ActorContext`` or ``ActorSystem``. Typically the "
"context is used for stopping child actors and the system for stopping top "
"level actors. The actual termination of the actor is performed "
"asynchronously, i.e. :meth:`stop` may return before the actor is stopped."
msgstr ""

# c97eca89c878460b94eb0f5fb797d60c
#: ../../scala/actors.rst:483
msgid ""
"Processing of the current message, if any, will continue before the actor is "
"stopped, but additional messages in the mailbox will not be processed. By "
"default these messages are sent to the :obj:`deadLetters` of the :obj:"
"`ActorSystem`, but that depends on the mailbox implementation."
msgstr ""

# d17309034df347228d1c35ef71e105bb
#: ../../scala/actors.rst:488
msgid ""
"Termination of an actor proceeds in two steps: first the actor suspends its "
"mailbox processing and sends a stop command to all its children, then it "
"keeps processing the termination messages from its children until the last "
"one is gone, finally terminating itself (invoking :meth:`postStop`, dumping "
"mailbox, publishing :class:`Terminated` on the :ref:`DeathWatch <deathwatch-"
"scala>`, telling its supervisor). This procedure ensures that actor system "
"sub-trees terminate in an orderly fashion, propagating the stop command to "
"the leaves and collecting their confirmation back to the stopped supervisor. "
"If one of the actors does not respond (i.e. processing a message for "
"extended periods of time and therefore not receiving the stop command), this "
"whole process will be stuck."
msgstr ""

# 44f3f221728b48499978de9ad1f4c0db
#: ../../scala/actors.rst:500
msgid ""
"Upon :meth:`ActorSystem.shutdown()`, the system guardian actors will be "
"stopped, and the aforementioned process will ensure proper termination of "
"the whole system."
msgstr ""

# bc9cfd8445764872b85447380aebf672
#: ../../scala/actors.rst:504
msgid ""
"The :meth:`postStop()` hook is invoked after an actor is fully stopped. This "
"enables cleaning up of resources:"
msgstr ""

# 2c4f84d71f2f4d97a1481b55b4940448
#: ../../scala/actors.rst:515
msgid ""
"Since stopping an actor is asynchronous, you cannot immediately reuse the "
"name of the child you just stopped; this will result in an :class:"
"`InvalidActorNameException`. Instead, :meth:`watch()` the terminating actor "
"and create its replacement in response to the :class:`Terminated` message "
"which will eventually arrive."
msgstr ""

# 540a53fb54e24f399531a2b8bf61af10
#: ../../scala/actors.rst:522
msgid "PoisonPill"
msgstr "毒薬"

# 47f58137e3ce493c87e462e3c0673069
#: ../../scala/actors.rst:524
msgid ""
"You can also send an actor the ``akka.actor.PoisonPill`` message, which will "
"stop the actor when the message is processed. ``PoisonPill`` is enqueued as "
"ordinary messages and will be handled after messages that were already "
"queued in the mailbox."
msgstr ""

# 4c0e2c87dce04d8c98d63dcc45c42be9
#: ../../scala/actors.rst:530
msgid "Graceful Stop"
msgstr "丁寧な停止"

# a4b42a1929244da9a978646c536f564e
#: ../../scala/actors.rst:532
msgid ""
":meth:`gracefulStop` is useful if you need to wait for termination or "
"compose ordered termination of several actors:"
msgstr ""

# 1a5ebb03a6d64e0894e49ab872bb7e25
#: ../../scala/actors.rst:541
msgid "Become/Unbecome"
msgstr "Become/Unbecome"

# 5548edad32b94b0fa70096ec1ac7395d
#: ../../scala/actors.rst:544
msgid "Upgrade"
msgstr "アップグレード"

# 8a01b293f21e407fa03bfad4db367574
#: ../../scala/actors.rst:546
msgid ""
"Akka supports hotswapping the Actor’s message loop (e.g. its implementation) "
"at runtime: Invoke the ``context.become`` method from within the Actor."
msgstr ""

# 999f15aa4b6944e6aa3966f066f269bd
#: ../../scala/actors.rst:549
msgid ""
"Become takes a ``PartialFunction[Any, Unit]`` that implements the new "
"message handler. The hotswapped code is kept in a Stack which can be pushed "
"and popped."
msgstr ""

# 5d173fd2182748cf995963a6229e110f
#: ../../scala/actors.rst:555
msgid ""
"Please note that the actor will revert to its original behavior when "
"restarted by its Supervisor."
msgstr ""

# 38dfe10033c24a7cb77b5ba2e056c56f
#: ../../scala/actors.rst:557
msgid "To hotswap the Actor behavior using ``become``:"
msgstr ""

# 95aa1889212f4a96a368bc5a5cb003d2
#: ../../scala/actors.rst:561
msgid ""
"The ``become`` method is useful for many different things, but a particular "
"nice example of it is in example where it is used to implement a Finite "
"State Machine (FSM): `Dining Hakkers`_."
msgstr ""

# 913bf45984554cec961b3869c99266c6
#: ../../scala/actors.rst:567
msgid ""
"Here is another little cute example of ``become`` and ``unbecome`` in action:"
msgstr ""

# e96bbda0ede446038c11171d1ce0a34f
#: ../../scala/actors.rst:572
msgid ""
"Encoding Scala Actors nested receives without accidentally leaking memory"
msgstr ""

# be554083f6894176ad8b24f56d0e6f56
#: ../../scala/actors.rst:574
msgid ""
"See this `Unnested receive example <https://github.com/akka/akka/blob/master/"
"akka-docs/scala/code/akka/docs/actor/UnnestedReceives.scala>`_."
msgstr ""

# 60cf6cf562934258af1d857eb2589430
#: ../../scala/actors.rst:578
msgid "Downgrade"
msgstr "ダウングレード"

# bdcd7a3d67734b9ebcedf5b6cc6233a8
#: ../../scala/actors.rst:580
msgid ""
"Since the hotswapped code is pushed to a Stack you can downgrade the code as "
"well, all you need to do is to: Invoke the ``context.unbecome`` method from "
"within the Actor."
msgstr ""

# eded0d9f3b594419ab59981dc7b17b9d
#: ../../scala/actors.rst:583
msgid ""
"This will pop the Stack and replace the Actor's implementation with the "
"``PartialFunction[Any, Unit]`` that is at the top of the Stack."
msgstr ""

# c6888dca47d74659a026f41862871b3c
#: ../../scala/actors.rst:586
msgid "Here's how you use the ``unbecome`` method:"
msgstr ""

# 22c63724640148cf832c6409488381bc
#: ../../scala/actors.rst:596
msgid "Killing an Actor"
msgstr "アクタを殺す"

# e8705ee9c3624372ae0c30054bf89b11
#: ../../scala/actors.rst:598
msgid ""
"You can kill an actor by sending a ``Kill`` message. This will restart the "
"actor through regular supervisor semantics."
msgstr ""

# 15462d177fa24bbda24b920cd6301e8e
#: ../../scala/actors.rst:601
msgid "Use it like this:"
msgstr "このように使います："

# 7b365677803e427986fa9e344917bede
#: ../../scala/actors.rst:610
msgid "Actors and exceptions"
msgstr "アクタと例外"

# 0c32cab9917941a6898acf65484ac09e
#: ../../scala/actors.rst:612
msgid ""
"It can happen that while a message is being processed by an actor, that some "
"kind of exception is thrown, e.g. a database exception."
msgstr ""

# 7fdf49dd594b4a49bb6b9df3f5b632dd
#: ../../scala/actors.rst:616
msgid "What happens to the Message"
msgstr "メッセージでは何が起きているか"

# bc229816c9944775bbf68376b9866bc8
#: ../../scala/actors.rst:618
msgid ""
"If an exception is thrown while a message is being processed (so taken of "
"his mailbox and handed over the the receive), then this message will be "
"lost. It is important to understand that it is not put back on the mailbox. "
"So if you want to retry processing of a message, you need to deal with it "
"yourself by catching the exception and retry your flow. Make sure that you "
"put a bound on the number of retries since you don't want a system to "
"livelock (so consuming a lot of cpu cycles without making progress)."
msgstr ""

# 44be6c3700814095ba41cec33b6dbbca
#: ../../scala/actors.rst:627
msgid "What happens to the mailbox"
msgstr "メールボックスでは何が起きているか"

# 7764aa200fd842e9816a2dd9775389aa
#: ../../scala/actors.rst:629
msgid ""
"If an exception is thrown while a message is being processed, nothing "
"happens to the mailbox. If the actor is restarted, the same mailbox will be "
"there. So all messages on that mailbox, will be there as well."
msgstr ""

# afcae2d653654dd2b73762be57e6ac43
#: ../../scala/actors.rst:634
msgid "What happens to the actor"
msgstr "アクタでは何が起きているか"

# a7f9ac57ecce47c49b70604cfc2fac37
#: ../../scala/actors.rst:636
msgid ""
"If an exception is thrown, the actor instance is discarded and a new "
"instance is created. This new instance will now be used in the actor "
"references to this actor (so this is done invisible to the developer). Note "
"that this means that current state of the failing actor instance is lost if "
"you don't store and restore it in ``preRestart`` and ``postRestart`` "
"callbacks."
msgstr ""

# dbf6717f36af408f9a3b3ce5e1880d1a
#: ../../scala/actors.rst:644
msgid "Extending Actors using PartialFunction chaining"
msgstr ""

# f08ac6a1377042098e035c58ee01d9b5
#: ../../scala/actors.rst:646
msgid ""
"A bit advanced but very useful way of defining a base message handler and "
"then extend that, either through inheritance or delegation, is to use "
"``PartialFunction.orElse`` chaining."
msgstr ""

# 9506626748214407ac0ececdd77687df
#: ../../scala/actors.rst:652
msgid "Or:"
msgstr ""

# dcbecc4f3a2a45458b972a3d2c77fc72
#: ../../scala/agents.rst:5
msgid "Agents (Scala)"
msgstr "エージェント (Scala)"

# 6fbe727b88f34ceba6cc4a9b9ae1142e
#: ../../scala/agents.rst:7
msgid "Agents in Akka are inspired by `agents in Clojure`_."
msgstr ""

# 3ce74d7bd29a476e87b8b92a0957ab25
#: ../../scala/agents.rst:11
msgid ""
"Agents provide asynchronous change of individual locations. Agents are bound "
"to a single storage location for their lifetime, and only allow mutation of "
"that location (to a new state) to occur as a result of an action. Update "
"actions are functions that are asynchronously applied to the Agent's state "
"and whose return value becomes the Agent's new state. The state of an Agent "
"should be immutable."
msgstr ""

# f96fbaf283c74ba59712becf3b389541
#: ../../scala/agents.rst:17
msgid ""
"While updates to Agents are asynchronous, the state of an Agent is always "
"immediately available for reading by any thread (using ``get`` or ``apply``) "
"without any messages."
msgstr ""

# e0941617345b47779d6cb312161770c6
#: ../../scala/agents.rst:21
msgid ""
"Agents are reactive. The update actions of all Agents get interleaved "
"amongst threads in a thread pool. At any point in time, at most one ``send`` "
"action for each Agent is being executed. Actions dispatched to an agent from "
"another thread will occur in the order they were sent, potentially "
"interleaved with actions dispatched to the same agent from other sources."
msgstr ""

# 2b0fae94c7494cdb8fcac16ab2d550ad
#: ../../scala/agents.rst:27
msgid ""
"If an Agent is used within an enclosing transaction, then it will "
"participate in that transaction. Agents are integrated with Scala STM - any "
"dispatches made in a transaction are held until that transaction commits, "
"and are discarded if it is retried or aborted."
msgstr ""

# d43de135adf94acfacfccdbcf5753d45
#: ../../scala/agents.rst:34
msgid "Creating and stopping Agents"
msgstr "エージェントの生成と停止"

# 491d7f76af91416f9967e2e0524e8972
#: ../../scala/agents.rst:36
msgid ""
"Agents are created by invoking ``Agent(value)`` passing in the Agent's "
"initial value:"
msgstr ""

# 0f736a6296e34e7d94a6f94b383ab980
#: ../../scala/agents.rst:41
msgid ""
"Note that creating an Agent requires an implicit ``ActorSystem`` (for "
"creating the underlying actors). See :ref:`actor-systems` for more "
"information about actor systems. An ActorSystem can be in implicit scope "
"when creating an Agent:"
msgstr ""

# 46f5ff01005a4d1abba1ec34055676ae
#: ../../scala/agents.rst:47
msgid "Or the ActorSystem can be passed explicitly when creating an Agent:"
msgstr ""

# 7105796c462f41ccbc38198f96cbea0d
#: ../../scala/agents.rst:51
msgid ""
"An Agent will be running until you invoke ``close`` on it. Then it will be "
"eligible for garbage collection (unless you hold on to it in some way)."
msgstr ""

# 92504a065d05446fa6744936ed2df34a
#: ../../scala/agents.rst:58
msgid "Updating Agents"
msgstr ""

# 7199a88ba0cb429e88d5a38160b1833c
#: ../../scala/agents.rst:60
msgid ""
"You update an Agent by sending a function that transforms the current value "
"or by sending just a new value. The Agent will apply the new value or "
"function atomically and asynchronously. The update is done in a fire-forget "
"manner and you are only guaranteed that it will be applied. There is no "
"guarantee of when the update will be applied but dispatches to an Agent from "
"a single thread will occur in order. You apply a value or a function by "
"invoking the ``send`` function."
msgstr ""

# d9d07d3ebe5c40848ae6da95ccea2c75
#: ../../scala/agents.rst:70
msgid ""
"You can also dispatch a function to update the internal state but on its own "
"thread. This does not use the reactive thread pool and can be used for long-"
"running or blocking operations. You do this with the ``sendOff`` method. "
"Dispatches using either ``sendOff`` or ``send`` will still be executed in "
"order."
msgstr ""

# 565612548e77457a9ee1283890bf0829
#: ../../scala/agents.rst:80
msgid "Reading an Agent's value"
msgstr ""

# 5e483706e4414555a8a8ac4b2553a5a1
#: ../../scala/agents.rst:82
msgid ""
"Agents can be dereferenced (you can get an Agent's value) by invoking the "
"Agent with parentheses like this:"
msgstr ""

# aa134cbbfb9f484d8b8fb42b5716862b
#: ../../scala/agents.rst:87
msgid "Or by using the get method:"
msgstr ""

# 1038bc1dc915452fb172061e1356eb3d
#: ../../scala/agents.rst:91
msgid ""
"Reading an Agent's current value does not involve any message passing and "
"happens immediately. So while updates to an Agent are asynchronous, reading "
"the state of an Agent is synchronous."
msgstr ""

# 3dd4b298f44744f68bd3486ae0da3000
#: ../../scala/agents.rst:97
msgid "Awaiting an Agent's value"
msgstr ""

# 5ee87ab9c986481dadf8449092eef61d
#: ../../scala/agents.rst:99
msgid ""
"It is also possible to read the value after all currently queued sends have "
"completed. You can do this with ``await``:"
msgstr ""

# 728ebecbe80542c49db317948a756889
#: ../../scala/agents.rst:104
msgid ""
"You can also get a ``Future`` to this value, that will be completed after "
"the currently queued updates have completed:"
msgstr ""

# c387cb3dd83e4c05a3ad8768b581a4bd
#: ../../scala/agents.rst:111
msgid "Transactional Agents"
msgstr ""

# 891f102c002e41fd857a55e0c242fd39
#: ../../scala/agents.rst:113
msgid ""
"If an Agent is used within an enclosing transaction, then it will "
"participate in that transaction. If you send to an Agent within a "
"transaction then the dispatch to the Agent will be held until that "
"transaction commits, and discarded if the transaction is aborted. Here's an "
"example:"
msgstr ""

# 54bd6487e95842d799a0cf868dc860b2
#: ../../scala/agents.rst:122
msgid "Monadic usage"
msgstr ""

# c4e82fce509b4506818dcc87c7bd9d30
#: ../../scala/agents.rst:124
msgid ""
"Agents are also monadic, allowing you to compose operations using for-"
"comprehensions. In monadic usage, new Agents are created leaving the "
"original Agents untouched. So the old values (Agents) are still available as-"
"is. They are so-called 'persistent'."
msgstr ""

# 11a27bfcfd254db188019d4856500798
#: ../../scala/agents.rst:129
msgid "Example of monadic usage:"
msgstr ""

# 06548d61a8d44f22852230293c2e0e56
#: ../../scala/dataflow.rst:2
msgid "Dataflow Concurrency (Scala)"
msgstr ""

# 3f844f74e7704834a37dac971829b78f
# 9de37e7ce5de4b9c98b0fbed77af810c
# 26ce948c98fe4cca8239239bf22c8052
#: ../../scala/dataflow.rst:5 ../../scala/fault-tolerance-sample.rst:15
#: ../../scala/fault-tolerance-sample.rst:35
msgid "Description"
msgstr ""

# 19447dc58dd94f9f9728ae9d612c06c1
#: ../../scala/dataflow.rst:7
msgid ""
"Akka implements `Oz-style dataflow concurrency <http://www.mozart-oz.org/"
"documentation/tutorial/node8.html#chapter.concurrency>`_ by using a special "
"API for :ref:`futures-scala` that allows single assignment variables and "
"multiple lightweight (event-based) processes/threads."
msgstr ""

# 11d4d523615943b9ad2c28e880485e18
#: ../../scala/dataflow.rst:9
msgid ""
"Dataflow concurrency is deterministic. This means that it will always behave "
"the same. If you run it once and it yields output 5 then it will do that "
"**every time**, run it 10 million times, same result. If it on the other "
"hand deadlocks the first time you run it, then it will deadlock **every "
"single time** you run it. Also, there is **no difference** between "
"sequential code and concurrent code. These properties makes it very easy to "
"reason about concurrency. The limitation is that the code needs to be side-"
"effect free, e.g. deterministic. You can't use exceptions, time, random "
"etc., but need to treat the part of your program that uses dataflow "
"concurrency as a pure function with input and output."
msgstr ""

# d5f01b72ec4841759465d0b1d56618cd
#: ../../scala/dataflow.rst:11
msgid ""
"The best way to learn how to program with dataflow variables is to read the "
"fantastic book `Concepts, Techniques, and Models of Computer Programming "
"<http://www.info.ucl.ac.be/%7Epvr/book.html>`_. By Peter Van Roy and Seif "
"Haridi."
msgstr ""

# 4e5ce7b928b14a848f18b8211ac11d0e
#: ../../scala/dataflow.rst:13
msgid ""
"The documentation is not as complete as it should be, something we will "
"improve shortly. For now, besides above listed resources on dataflow "
"concurrency, I recommend you to read the documentation for the GPars "
"implementation, which is heavily influenced by the Akka implementation:"
msgstr ""

# fcd50329b5c949d59f7b7ba0d1b8a453
#: ../../scala/dataflow.rst:15
msgid "`<http://gpars.codehaus.org/Dataflow>`_"
msgstr ""

# 23323ad8ea0444898338bf63a5b60afe
#: ../../scala/dataflow.rst:16
msgid "`<http://www.gpars.org/guide/guide/7.%20Dataflow%20Concurrency.html>`_"
msgstr ""

# 7d094a977a4241e997a10ad424593b6e
#: ../../scala/dataflow.rst:19
msgid "Getting Started"
msgstr ""

# d02bd86ae38f42df9b8cabc51781bcbc
#: ../../scala/dataflow.rst:21
msgid ""
"Scala's Delimited Continuations plugin is required to use the Dataflow API. "
"To enable the plugin when using sbt, your project must inherit the "
"``AutoCompilerPlugins`` trait and contain a bit of configuration as is seen "
"in this example:"
msgstr ""

# fa63f5bb34f64cbf8f32c18d7fe8ec99
#: ../../scala/dataflow.rst:30
msgid "Dataflow Variables"
msgstr ""

# 5499ce5170874dde93a8649049ac4d9e
#: ../../scala/dataflow.rst:32
msgid "Dataflow Variable defines four different operations:"
msgstr ""

# 1cd1a892d8ad4b02bf4a025296022b36
#: ../../scala/dataflow.rst:34
msgid "Define a Dataflow Variable"
msgstr ""

# 016ecf2c144c48b08369882cf34065c7
#: ../../scala/dataflow.rst:40
msgid ""
"Wait for Dataflow Variable to be bound (must be contained within a ``Future."
"flow`` block as described in the next section)"
msgstr ""

# d2b90a4fbac14f4f8d981725dee31751
#: ../../scala/dataflow.rst:46
msgid ""
"Bind Dataflow Variable (must be contained within a ``Future.flow`` block as "
"described in the next section)"
msgstr ""

# b7150ef161c94fc98ea71bddac1f1728
#: ../../scala/dataflow.rst:52
msgid ""
"Bind Dataflow Variable with a Future (must be contained within a ``Future."
"flow`` block as described in the next section)"
msgstr ""

# 96390b7730bd4ad1b7f7f509d533ed6c
#: ../../scala/dataflow.rst:58
msgid ""
"A Dataflow Variable can only be bound once. Subsequent attempts to bind the "
"variable will be ignored."
msgstr ""

# c53ea2d03dca46448b37fef93ce7e4b6
#: ../../scala/dataflow.rst:61
msgid "Dataflow Delimiter"
msgstr ""

# cb1e4bef933448baab0e0ec1a7dcb263
#: ../../scala/dataflow.rst:63
msgid ""
"Dataflow is implemented in Akka using Scala's Delimited Continuations. To "
"use the Dataflow API the code must be contained within a ``Future.flow`` "
"block. For example:"
msgstr ""

# dc10d7d325424fcc9d4ea658ffa6d6b8
#: ../../scala/dataflow.rst:80
msgid ""
"The ``flow`` method also returns a ``Future`` for the result of the "
"contained expression, so the previous example could also be written like "
"this:"
msgstr ""

# 3614219ecf8245bbae0badbcbd470fae
# e6e655b70e6748ed91253268f52956e2
# 0fba8662ecaf434eb146bc263747b2c4
#: ../../scala/dataflow.rst:97 ../../scala/fsm.rst:489 ../../scala/io.rst:99
msgid "Examples"
msgstr ""

# a73ea797069b43209ca0655b2465502e
#: ../../scala/dataflow.rst:99
msgid ""
"Most of these examples are taken from the `Oz wikipedia page <http://en."
"wikipedia.org/wiki/Oz_%28programming_language%29>`_"
msgstr ""

# 613978ff55e043a9a77a754d4a84b411
#: ../../scala/dataflow.rst:101
msgid "To run these examples:"
msgstr ""

# 4431052394c4427dbbf6e2ed040b3a93
#: ../../scala/dataflow.rst:103
msgid "Start REPL"
msgstr ""

# a29aad99d329435cad71702f8dc35c76
#: ../../scala/dataflow.rst:119
msgid ""
"2. Paste the examples (below) into the Scala REPL. Note: Do not try to run "
"the Oz version, it is only there for reference."
msgstr ""

# 3bc2d80f446c4629878bab223903967d
#: ../../scala/dataflow.rst:122
msgid "Have fun."
msgstr ""

# 83a2f21b01214fd4b870c8abf83dd489
#: ../../scala/dataflow.rst:125
msgid "Simple DataFlowVariable example"
msgstr ""

# 0ea3077e168548109a1aa16346959091
#: ../../scala/dataflow.rst:127
msgid ""
"This example is from Oz wikipedia page: http://en.wikipedia.org/wiki/Oz_"
"(programming_language). Sort of the \"Hello World\" of dataflow concurrency."
msgstr ""

# fe90ae8eb193477b99f234a8c07b62c4
# a02da4a33881497e86625ba71c0646c0
#: ../../scala/dataflow.rst:130 ../../scala/dataflow.rst:163
msgid "Example in Oz:"
msgstr ""

# 3876af5a994f4f00ba86c4e715d4f27b
# 9cce1b424a124ee89e9a47e697ec07f8
# 55b7451965304b93b0f714b560ec26e8
#: ../../scala/dataflow.rst:141 ../../scala/dataflow.rst:186
#: ../../scala/dataflow.rst:215
msgid "Example in Akka:"
msgstr ""

# c816579af3494b138310ad671a689337
#: ../../scala/dataflow.rst:159
msgid "Example of using DataFlowVariable with recursion"
msgstr ""

# a49b8e84b70c44e492ab5c7271dbbf95
#: ../../scala/dataflow.rst:161
msgid "Using DataFlowVariable and recursion to calculate sum."
msgstr ""

# 3c72d4ff06a3483ea0d63bfd29929d64
#: ../../scala/dataflow.rst:211
msgid "Example using concurrent Futures"
msgstr ""

# 33ca5f8dae2c472fb787754747fc4175
#: ../../scala/dataflow.rst:213
msgid "Shows how to have a calculation run in another thread."
msgstr ""

# 22e95360276c415b85801ee7b44743a7
#: ../../scala/dispatchers.rst:4
msgid "Dispatchers (Scala)"
msgstr ""

# 967193d396c64b41a3b66cd441bc4573
#: ../../scala/dispatchers.rst:6
msgid ""
"An Akka ``MessageDispatcher`` is what makes Akka Actors \"tick\", it is the "
"engine of the machine so to speak. All ``MessageDispatcher`` implementations "
"are also an ``ExecutionContext``, which means that they can be used to "
"execute arbitrary code, for instance :ref:`futures-scala`."
msgstr ""

# 14a2eb739f724894b9af2234fb5409a0
#: ../../scala/dispatchers.rst:11
msgid "Default dispatcher"
msgstr ""

# fb97fe1580e84694aedc1c3044755883
#: ../../scala/dispatchers.rst:13
msgid ""
"Every ``ActorSystem`` will have a default dispatcher that will be used in "
"case nothing else is configured for an ``Actor``. The default dispatcher can "
"be configured, and is by default a ``Dispatcher`` with a \"fork-join-executor"
"\", which gives excellent performance in most cases."
msgstr ""

# dda97fca66da482e8f28ca833d91c7e7
#: ../../scala/dispatchers.rst:17
msgid "Setting the dispatcher for an Actor"
msgstr ""

# 36ec206acb234aa3bf5a9b0ee13c44cd
#: ../../scala/dispatchers.rst:19
msgid ""
"So in case you want to give your ``Actor`` a different dispatcher than the "
"default, you need to do two things, of which the first is:"
msgstr ""

# 0e3a4559e0da4ce08eda3f5a2b530c11
#: ../../scala/dispatchers.rst:24
msgid ""
"The \"dispatcherId\" you specify in withDispatcher is in fact a path into "
"your configuration. So in this example it's a top-level section, but you "
"could for instance put it as a sub-section, where you'd use periods to "
"denote sub-sections, like this: ``\"foo.bar.my-dispatcher\"``"
msgstr ""

# 569b150329f94ca3a9c6dfcf7aaa431a
#: ../../scala/dispatchers.rst:28
msgid ""
"And then you just need to configure that dispatcher in your configuration:"
msgstr ""

# 8e4797eac7b84a59ba08138eee20430d
#: ../../scala/dispatchers.rst:32
msgid "And here's another example that uses the \"thread-pool-executor\":"
msgstr ""

# 2f46e7a4b56d4d30b9a317eab56c401d
#: ../../scala/dispatchers.rst:36
msgid ""
"For more options, see the default-dispatcher section of the :ref:"
"`configuration`."
msgstr ""

# 8d22a0d57c664dbcb64d91bdebc80d13
#: ../../scala/dispatchers.rst:39
msgid "Types of dispatchers"
msgstr ""

# ef6dd33a721740ee8ac05c7e84b14727
#: ../../scala/dispatchers.rst:41
msgid "There are 4 different types of message dispatchers:"
msgstr ""

# 5209406a923f4e77b9f4fbd1fb5a9dc3
#: ../../scala/dispatchers.rst:43
msgid "Dispatcher"
msgstr ""

# 1da9345d98224730a938548208be2052
# 97efa1d1133a476c921cac41eea17886
#: ../../scala/dispatchers.rst:45 ../../scala/dispatchers.rst:82
msgid "Sharability: Unlimited"
msgstr ""

# a4c956d054794617802c66049e842838
# f2f11574e7a545fc80340e569d932559
#: ../../scala/dispatchers.rst:47 ../../scala/dispatchers.rst:60
msgid "Mailboxes: Any, creates one per Actor"
msgstr ""

# 3ec2c77df41e4c4e8873e85b1eceacb7
#: ../../scala/dispatchers.rst:49
msgid "Use cases: Default dispatcher, Bulkheading"
msgstr ""

# 8d8ab62f041d426d9a11f48dae05326a
# 7ba3534e4c404b24a322d7939741d88c
#: ../../scala/dispatchers.rst:52 ../../scala/dispatchers.rst:76
msgid ""
"specify using \"executor\" using \"fork-join-executor\", \"thread-pool-"
"executor\" or the FQCN of an ``akka.dispatcher.ExecutorServiceConfigurator``"
msgstr ""

# 31305234259448aa95e3e1d93a10d5ae
#: ../../scala/dispatchers.rst:56
msgid "PinnedDispatcher"
msgstr ""

# 61557e20aeec4549965486176b420632
#: ../../scala/dispatchers.rst:58
msgid "Sharability: None"
msgstr ""

# 8627869a48b84b8185431726ea305688
#: ../../scala/dispatchers.rst:62
msgid "Use cases: Bulkheading"
msgstr ""

# a6bbc55ace2c460a8bafd011219eb5b6
#: ../../scala/dispatchers.rst:65
msgid "by default a \"thread-pool-executor\""
msgstr ""

# d559b8e74bfa46338ea5efb2b87d70d4
#: ../../scala/dispatchers.rst:67
msgid "BalancingDispatcher"
msgstr ""

# ae394b426447478b914cae9bc6bf15ed
#: ../../scala/dispatchers.rst:69
msgid "Sharability: Actors of the same type only"
msgstr ""

# 2847c961cf9b40dab41891919680afd9
#: ../../scala/dispatchers.rst:71
msgid "Mailboxes: Any, creates one for all Actors"
msgstr ""

# a0795e0d69724491a98fc1cc08dbba3e
#: ../../scala/dispatchers.rst:73
msgid "Use cases: Work-sharing"
msgstr ""

# 6e111e6e52684c9797c6dfb502290d30
# 51b4dfaf60de4f3fab033a23d8c804ae
#: ../../scala/dispatchers.rst:80 ../../scala/testing.rst:501
msgid "CallingThreadDispatcher"
msgstr ""

# 5fb5995e40394d56bfbe979bb4b27546
#: ../../scala/dispatchers.rst:84
msgid "Mailboxes: Any, creates one per Actor per Thread (on demand)"
msgstr ""

# 108bbea1d80b4d75a4a25145957d59b8
#: ../../scala/dispatchers.rst:86
msgid "Use cases: Testing"
msgstr ""

# 8713ed11583c45718d8cbe314f1d3cc4
#: ../../scala/dispatchers.rst:88
msgid "Driven by: The calling thread (duh)"
msgstr ""

# 12032fdaf1da4f77a9009af2dcb91588
#: ../../scala/dispatchers.rst:91
msgid "More dispatcher configuration examples"
msgstr ""

# ea55440bcff74c9cb9b02b79c7128a7f
#: ../../scala/dispatchers.rst:93
msgid "Configuring a ``PinnedDispatcher``:"
msgstr ""

# 9a5452439a234d5ab024d71179c47ad7
#: ../../scala/dispatchers.rst:97
msgid "And then using it:"
msgstr ""

# 4fb8b39384644788bbf7475745823dd8
#: ../../scala/dispatchers.rst:102
msgid "Mailboxes"
msgstr ""

# 7caa5d9f76ce4bf5948edb45e89d8851
#: ../../scala/dispatchers.rst:104
msgid ""
"An Akka ``Mailbox`` holds the messages that are destined for an ``Actor``. "
"Normally each ``Actor`` has its own mailbox, but with example a "
"``BalancingDispatcher`` all actors with the same ``BalancingDispatcher`` "
"will share a single instance."
msgstr ""

# 74205240a2844f4791aac250967d52fe
#: ../../scala/dispatchers.rst:108
msgid "Builtin implementations"
msgstr ""

# df229ad726cf4bb4aca33443d8115102
#: ../../scala/dispatchers.rst:110
msgid "Akka comes shipped with a number of default mailbox implementations:"
msgstr ""

# 99adc1841ffc47cda1f144b2864abdb3
#: ../../scala/dispatchers.rst:112
msgid "UnboundedMailbox"
msgstr ""

# 323c4fdac3614c9dad93f2bd997a13e4
#: ../../scala/dispatchers.rst:114
msgid "Backed by a ``java.util.concurrent.ConcurrentLinkedQueue``"
msgstr ""

# 71e6d538436a42d3ab5c6e0356a2cdfd
#: ../../scala/dispatchers.rst:116
msgid "Blocking: No"
msgstr ""

# df901095e7f8490f8575c562da7ce1d2
# 415a0386f0064a9faa76846a98fd7ff6
#: ../../scala/dispatchers.rst:118 ../../scala/dispatchers.rst:134
msgid "Bounded: No"
msgstr ""

# 83a443c9624b491589f3d3cc67612fd3
#: ../../scala/dispatchers.rst:120
msgid "BoundedMailbox"
msgstr ""

# 1defcf74341a45caa139d8f38975ff6b
#: ../../scala/dispatchers.rst:122
msgid "Backed by a ``java.util.concurrent.LinkedBlockingQueue``"
msgstr ""

# 2daf4d0acb0e430d93e18cbdd0762a2a
# d570ff3091934bc0814617e1ae52e9ab
# 85092dc0f54c4c87884107482b415530
#: ../../scala/dispatchers.rst:124 ../../scala/dispatchers.rst:132
#: ../../scala/dispatchers.rst:140
msgid "Blocking: Yes"
msgstr ""

# 6d2d3b385ffc46948fba2307c1f9d0b6
# b6523c34a2a44408bcc7305c342684cf
#: ../../scala/dispatchers.rst:126 ../../scala/dispatchers.rst:142
msgid "Bounded: Yes"
msgstr ""

# b2e821d9877444acb2dd2e2201636787
#: ../../scala/dispatchers.rst:128
msgid "UnboundedPriorityMailbox"
msgstr ""

# 756572f7f1044a62bc28fac77c5d2cc2
#: ../../scala/dispatchers.rst:130
msgid "Backed by a ``java.util.concurrent.PriorityBlockingQueue``"
msgstr ""

# 5a69204cabad4b03adbdc8ca946a5d99
#: ../../scala/dispatchers.rst:136
msgid "BoundedPriorityMailbox"
msgstr ""

# 9936059e831e44e79ee6c15cb8047758
#: ../../scala/dispatchers.rst:138
msgid ""
"Backed by a ``java.util.PriorityBlockingQueue`` wrapped in an ``akka.util."
"BoundedBlockingQueue``"
msgstr ""

# a1c896407e464403b9636a89036c03ef
#: ../../scala/dispatchers.rst:144
msgid "Durable mailboxes, see :ref:`durable-mailboxes`."
msgstr ""

# 277338a0171a47b3a8e5fc43a9995809
#: ../../scala/dispatchers.rst:147
msgid "Mailbox configuration examples"
msgstr ""

# 9227738ca6694d1fb75eb2ef4b2fb124
#: ../../scala/dispatchers.rst:149
msgid "How to create a PriorityMailbox:"
msgstr ""

# dcde509314f44bf18119a0c96f79aaae
#: ../../scala/dispatchers.rst:153
msgid "And then add it to the configuration:"
msgstr ""

# 71fbf08edf7b48ea975eb31b74edca3f
#: ../../scala/dispatchers.rst:157
msgid "And then an example on how you would use it:"
msgstr ""

# 71f40af486d841e7abbac0ccdb2a0d99
#: ../../scala/dispatchers.rst:162
msgid "Creating your own Mailbox type"
msgstr ""

# 3c5802d9a3bf49698bbc906787eecc92
#: ../../scala/dispatchers.rst:164
msgid "An example is worth a thousand quacks:"
msgstr ""

# d9289e49160a429f8b08ddae2dc5da87
#: ../../scala/dispatchers.rst:168
msgid ""
"And then you just specify the FQCN of your MailboxType as the value of the "
"\"mailbox-type\" in the dispatcher configuration."
msgstr ""

# d93279f87aab46449850b8667838eba5
#: ../../scala/dispatchers.rst:172
msgid ""
"Make sure to include a constructor which takes ``akka.actor.ActorSystem."
"Settings`` and ``com.typesafe.config.Config`` arguments, as this constructor "
"is invoked reflectively to construct your mailbox type. The config passed in "
"as second argument is that section from the configuration which describes "
"the dispatcher using this mailbox type; the mailbox type will be "
"instantiated once for each dispatcher using it."
msgstr ""

# 7d342dab94344eb38727cd590bc0c511
#: ../../scala/event-bus.rst:5
msgid "Event Bus (Scala)"
msgstr ""

# e8d83bf9d25048b99e2d98433d89c6e3
#: ../../scala/event-bus.rst:8
msgid ""
"Originally conceived as a way to send messages to groups of actors, the :"
"class:`EventBus` has been generalized into a set of composable traits "
"implementing a simple interface:"
msgstr ""

# 2a9269a1282e4b79878366e9acc64569
#: ../../scala/event-bus.rst:12
msgid ""
":meth:`subscribe(subscriber: Subscriber, classifier: Classifier): Boolean` "
"subscribes the given subscriber to events with the given classifier"
msgstr ""

# 7c58a6bb1079490da50d5c19b681a18f
#: ../../scala/event-bus.rst:15
msgid ""
":meth:`unsubscribe(subscriber: Subscriber, classifier: Classifier): Boolean` "
"undoes a specific subscription"
msgstr ""

# 8637afb003014833b5e96be6709268b3
#: ../../scala/event-bus.rst:18
msgid ""
":meth:`unsubscribe(subscriber: Subscriber)` undoes all subscriptions for the "
"given subscriber"
msgstr ""

# 11a57f5016a54e17b8f7436b157cd7ec
#: ../../scala/event-bus.rst:21
msgid ""
":meth:`publish(event: Event)` publishes an event, which first is classified "
"according to the specific bus (see `Classifiers`_) and then published to all "
"subscribers for the obtained classifier"
msgstr ""

# d39d619c8e864a68bbbe0797082b853e
#: ../../scala/event-bus.rst:25
msgid ""
"This mechanism is used in different places within Akka, e.g. the :ref:"
"`DeathWatch <deathwatch-scala>` and the `Event Stream`_. Implementations can "
"make use of the specific building blocks presented below."
msgstr ""

# 665d9c65d7dd4b9bbfead44c1a5c720c
#: ../../scala/event-bus.rst:29
msgid "An event bus must define the following three abstract types:"
msgstr ""

# 0ba276025e2846238c5b2117f6e6bf98
#: ../../scala/event-bus.rst:31
msgid ":class:`Event` is the type of all events published on that bus"
msgstr ""

# 0b20e8f8d67b4c91802e1a63daec5bc2
#: ../../scala/event-bus.rst:33
msgid ""
":class:`Subscriber` is the type of subscribers allowed to register on that "
"event bus"
msgstr ""

# 21ad2bd53b5a422cad4c963c42d647a2
#: ../../scala/event-bus.rst:36
msgid ""
":class:`Classifier` defines the classifier to be used in selecting "
"subscribers for dispatching events"
msgstr ""

# f1ff61eec85c4f1da0371fbedd6c1839
#: ../../scala/event-bus.rst:39
msgid ""
"The traits below are still generic in these types, but they need to be "
"defined for any concrete implementation."
msgstr ""

# 7f8239added24dd2bdf46504eb1c3fea
#: ../../scala/event-bus.rst:43
msgid "Classifiers"
msgstr ""

# 1a85120a0bb44e8ca566da64b9798d06
#: ../../scala/event-bus.rst:45
msgid ""
"The classifiers presented here are part of the Akka distribution, but "
"rolling your own in case you do not find a perfect match is not difficult, "
"check the implementation of the existing ones on `github`_."
msgstr ""

# 973ea75c0ce14fe9aded27b91f621b3d
#: ../../scala/event-bus.rst:52
msgid "Lookup Classification"
msgstr ""

# a7c0ffc335a0495783ead0ff70ad0ed5
#: ../../scala/event-bus.rst:54
msgid ""
"The simplest classification is just to extract an arbitrary classifier from "
"each event and maintaining a set of subscribers for each possible "
"classifier. This can be compared to tuning in on a radio station. The trait :"
"class:`LookupClassification` is still generic in that it abstracts over how "
"to compare subscribers and how exactly to classify. The necessary methods to "
"be implemented are the following:"
msgstr ""

# b4c5a58326a14c859b58386b1dae4941
# ee24000dc3c84ee3b61708c9b9686707
#: ../../scala/event-bus.rst:61 ../../scala/event-bus.rst:93
msgid ""
":meth:`classify(event: Event): Classifier` is used for extracting the "
"classifier from the incoming events."
msgstr ""

# 594e8b7cee32489cb02445f0475c7dc3
#: ../../scala/event-bus.rst:64
msgid ""
":meth:`compareSubscribers(a: Subscriber, b: Subscriber): Int` must define a "
"partial order over the subscribers, expressed as expected from :meth:`java."
"lang.Comparable.compare`."
msgstr ""

# de134eaec745454b9d6431a7ce129ce0
# cb0ad10cc677451da7940c3e6a28aa22
#: ../../scala/event-bus.rst:68 ../../scala/event-bus.rst:96
msgid ""
":meth:`publish(event: Event, subscriber: Subscriber)` will be invoked for "
"each event for all subscribers which registered themselves for the event’s "
"classifier."
msgstr ""

# c4200a019f6b4af8802b9d92730bc840
# c57af73e2d0147e7a69c245b53e75717
#: ../../scala/event-bus.rst:72 ../../scala/event-bus.rst:143
msgid ""
":meth:`mapSize: Int` determines the initial size of the index data structure "
"used internally (i.e. the expected number of different classifiers)."
msgstr ""

# 72d9cdd85d0341eba45ff9debd09c830
#: ../../scala/event-bus.rst:75
msgid ""
"This classifier is efficient in case no subscribers exist for a particular "
"event."
msgstr ""

# f264aaeeccb040c2af7c05ed1e71f0f7
#: ../../scala/event-bus.rst:78
msgid "Subchannel Classification"
msgstr ""

# 89615a80f0f04090b9a13bebada3ff0c
#: ../../scala/event-bus.rst:80
msgid ""
"If classifiers form a hierarchy and it is desired that subscription be "
"possible not only at the leaf nodes, this classification may be just the "
"right one. It can be compared to tuning in on (possibly multiple) radio "
"channels by genre. This classification has been developed for the case where "
"the classifier is just the JVM class of the event and subscribers may be "
"interested in subscribing to all subclasses of a certain class, but it may "
"be used with any classifier hierarchy. The abstract members needed by this "
"classifier are"
msgstr ""

# 721ced60227c4b92978158a0011e8d02
#: ../../scala/event-bus.rst:88
msgid ""
":obj:`subclassification: Subclassification[Classifier]` is an object "
"providing :meth:`isEqual(a: Classifier, b: Classifier)` and :meth:`isSubclass"
"(a: Classifier, b: Classifier)` to be consumed by the other methods of this "
"classifier."
msgstr ""

# 7e5376bf46f042c08d6a1bac0ab417c2
#: ../../scala/event-bus.rst:100
msgid ""
"This classifier is also efficient in case no subscribers are found for an "
"event, but it uses conventional locking to synchronize an internal "
"classifier cache, hence it is not well-suited to use cases in which "
"subscriptions change with very high frequency (keep in mind that “opening” a "
"classifier by sending the first message will also have to re-check all "
"previous subscriptions)."
msgstr ""

# ba9b43275b954bb392e23cb5e3db4079
#: ../../scala/event-bus.rst:107
msgid "Scanning Classification"
msgstr ""

# f8c5e6ec45404c428771914345fa759f
#: ../../scala/event-bus.rst:109
msgid ""
"The previous classifier was built for multi-classifier subscriptions which "
"are strictly hierarchical, this classifier is useful if there are "
"overlapping classifiers which cover various parts of the event space without "
"forming a hierarchy. It can be compared to tuning in on (possibly multiple) "
"radio stations by geographical reachability (for old-school radio-wave "
"transmission). The abstract members for this classifier are:"
msgstr ""

# 3c2c4c779ced4ab9a9647b13c1f0734d
#: ../../scala/event-bus.rst:116
msgid ""
":meth:`compareClassifiers(a: Classifier, b: Classifier): Int` is needed for "
"determining matching classifiers and storing them in an ordered collection."
msgstr ""

# 457bcb3bae364e26a21ebda27bf4bf56
#: ../../scala/event-bus.rst:119
msgid ""
":meth:`compareSubscribers(a: Subscriber, b: Subscriber): Int` is needed for "
"storing subscribers in an ordered collection."
msgstr ""

# 959632f6e39c4423b1e51bcc9e685ff0
#: ../../scala/event-bus.rst:122
msgid ""
":meth:`matches(classifier: Classifier, event: Event): Boolean` determines "
"whether a given classifier shall match a given event; it is invoked for each "
"subscription for all received events, hence the name of the classifier."
msgstr ""

# 710b30b3d2754db4b72e085b469a85ef
#: ../../scala/event-bus.rst:126
msgid ""
":meth:`publish(event: Event, subscriber: Subscriber)` will be invoked for "
"each event for all subscribers which registered themselves for a classifier "
"matching this event."
msgstr ""

# 27f27c0d47534516b29223bcffa158c1
#: ../../scala/event-bus.rst:130
msgid ""
"This classifier takes always a time which is proportional to the number of "
"subscriptions, independent of how many actually match."
msgstr ""

# 037e191421e541079b37f42f0109b797
#: ../../scala/event-bus.rst:134
msgid "Actor Classification"
msgstr ""

# 8b75567465c945d7b5dde74aaa2607b5
#: ../../scala/event-bus.rst:136
msgid ""
"This classification has been developed specifically for implementing :ref:"
"`DeathWatch <deathwatch-scala>`: subscribers as well as classifiers are of "
"type :class:`ActorRef`. The abstract members are"
msgstr ""

# d75a7962a43941d98b03adca38809dba
#: ../../scala/event-bus.rst:140
msgid ""
":meth:`classify(event: Event): ActorRef` is used for extracting the "
"classifier from the incoming events."
msgstr ""

# 0ab4c79260fa4eb49322f8cd02ece162
#: ../../scala/event-bus.rst:146
msgid ""
"This classifier is still is generic in the event type, and it is efficient "
"for all use cases."
msgstr ""

# 2c1ef8139cdf4dcdab5dc4f1b2f274ea
#: ../../scala/event-bus.rst:152
msgid "Event Stream"
msgstr ""

# b6789495730844979cb91e5d447e26cc
#: ../../scala/event-bus.rst:154
msgid ""
"The event stream is the main event bus of each actor system: it is used for "
"carrying :ref:`log messages <logging-scala>` and `Dead Letters`_ and may be "
"used by the user code for other purposes as well. It uses `Subchannel "
"Classification`_ which enables registering to related sets of channels (as "
"is used for :class:`RemoteLifeCycleMessage`). The following example "
"demonstrates how a simple subscription works:"
msgstr ""

# a4309735012d4c6e8bb2409de3cefea5
#: ../../scala/event-bus.rst:164
msgid "Default Handlers"
msgstr ""

# 264a9fae0e0c45e5aeb372595e377904
#: ../../scala/event-bus.rst:166
msgid ""
"Upon start-up the actor system creates and subscribes actors to the event "
"stream for logging: these are the handlers which are configured for example "
"in ``application.conf``:"
msgstr ""

# 34937d32a16d4cbfa79141a36592b8c4
#: ../../scala/event-bus.rst:176
msgid ""
"The handlers listed here by fully-qualified class name will be subscribed to "
"all log event classes with priority higher than or equal to the configured "
"log-level and their subscriptions are kept in sync when changing the log-"
"level at runtime::"
msgstr ""

# 2bb223d7d5e140f9afd72c11d028b363
#: ../../scala/event-bus.rst:183
msgid ""
"This means that log events for a level which will not be logged are not "
"typically not dispatched at all (unless manual subscriptions to the "
"respective event class have been done)"
msgstr ""

# bd2800f0ec0f46a885877d96567fe0b5
#: ../../scala/event-bus.rst:188
msgid "Dead Letters"
msgstr ""

# 67716878c108479f90573b9fca83658b
#: ../../scala/event-bus.rst:190
msgid ""
"As described at :ref:`stopping-actors-scala`, messages queued when an actor "
"terminates or sent after its death are re-routed to the dead letter mailbox, "
"which by default will publish the messages wrapped in :class:`DeadLetter`. "
"This wrapper holds the original sender, receiver and message of the envelope "
"which was redirected."
msgstr ""

# 31cd1c929049485b8d0ad3fffefda6e8
#: ../../scala/event-bus.rst:197
msgid "Other Uses"
msgstr ""

# 62b86e2a00a646caad2d5a8c1adb64ae
#: ../../scala/event-bus.rst:199
msgid ""
"The event stream is always there and ready to be used, just publish your own "
"events (it accepts ``AnyRef``) and subscribe listeners to the corresponding "
"JVM classes."
msgstr ""

# 9ec0ed90d47f4ad788a62821483c6039
#: ../../scala/extending-akka.rst:5
msgid "Akka Extensions (Scala)"
msgstr ""

# f1e7edb706d54d4392ac8732ebf3cb7b
#: ../../scala/extending-akka.rst:8
msgid ""
"If you want to add features to Akka, there is a very elegant, but powerful "
"mechanism for doing so. It's called Akka Extensions and is comprised of 2 "
"basic components: an ``Extension`` and an ``ExtensionId``."
msgstr ""

# 20cc82656dab4c47850513600280d45b
#: ../../scala/extending-akka.rst:11
msgid ""
"Extensions will only be loaded once per ``ActorSystem``, which will be "
"managed by Akka. You can choose to have your Extension loaded on-demand or "
"at ``ActorSystem`` creation time through the Akka configuration. Details on "
"how to make that happens are below, in the \"Loading from Configuration\" "
"section."
msgstr ""

# 7d039031da2c45f0895926fd9c34280d
#: ../../scala/extending-akka.rst:17
msgid ""
"Since an extension is a way to hook into Akka itself, the implementor of the "
"extension needs to ensure the thread safety of his/her extension."
msgstr ""

# 3f7aa8d4329f47e1b32d72fc41c71872
#: ../../scala/extending-akka.rst:21
msgid "Building an Extension"
msgstr ""

# 23181771eb4d49d2905c5d95faaccba3
#: ../../scala/extending-akka.rst:23
msgid ""
"So let's create a sample extension that just lets us count the number of "
"times something has happened."
msgstr ""

# f0737509b77e438aaa48276d6c0996a4
#: ../../scala/extending-akka.rst:25
msgid "First, we define what our ``Extension`` should do:"
msgstr ""

# 7f1cc87fcdaf4e928f560c34382a5d14
#: ../../scala/extending-akka.rst:30
msgid ""
"Then we need to create an ``ExtensionId`` for our extension so we can grab "
"ahold of it."
msgstr ""

# 305c5f609e6e47a791ca9989b42c02d9
#: ../../scala/extending-akka.rst:35
msgid "Wicked! Now all we need to do is to actually use it:"
msgstr ""

# 76637bde39a8483b9b957fcdff21a24e
#: ../../scala/extending-akka.rst:40
msgid "Or from inside of an Akka Actor:"
msgstr ""

# b36bfec873b14c6aaf00e52c72564557
#: ../../scala/extending-akka.rst:45
msgid "You can also hide extension behind traits:"
msgstr ""

# 94daba2b08d943198a5b31cd71190013
#: ../../scala/extending-akka.rst:50
msgid "That's all there is to it!"
msgstr ""

# 6c3a9176a91348bf905692c7dbd6232a
#: ../../scala/extending-akka.rst:53
msgid "Loading from Configuration"
msgstr ""

# f2e9da2733d041608b310e3e1556d146
#: ../../scala/extending-akka.rst:55
msgid ""
"To be able to load extensions from your Akka configuration you must add "
"FQCNs of implementations of either ``ExtensionId`` or "
"``ExtensionIdProvider`` in the ``akka.extensions`` section of the config you "
"provide to your ``ActorSystem``."
msgstr ""

# c3a3cab356b640dbacea1a2bcf6f6b7c
#: ../../scala/extending-akka.rst:61
msgid ""
"Note that in this case ``CountExtension`` is an object and therefore the "
"class name ends with ``$``."
msgstr ""

# 8f023280c198415e9c73b7156e256fd5
#: ../../scala/extending-akka.rst:64
msgid "Applicability"
msgstr ""

# 4d1d94254ab54f169d973f88d9c2cd23
#: ../../scala/extending-akka.rst:66
msgid ""
"The sky is the limit! By the way, did you know that Akka's ``Typed Actors``, "
"``Serialization`` and other features are implemented as Akka Extensions?"
msgstr ""

# c26908bc595a4c84a580ee4304f37927
#: ../../scala/extending-akka.rst:72
msgid "Application specific settings"
msgstr ""

# 78189b84ef974509ad3b3b666df28dde
#: ../../scala/extending-akka.rst:74
msgid ""
"The :ref:`configuration` can be used for application specific settings. A "
"good practice is to place those settings in an Extension."
msgstr ""

# 80e43ea338cc4dee92ecce6533f702aa
#: ../../scala/extending-akka.rst:76
msgid "Sample configuration:"
msgstr ""

# f7b1fc9e4d494c5c98ddea09c57d4250
#: ../../scala/extending-akka.rst:81
msgid "The ``Extension``:"
msgstr ""

# 3ef4ad12269843c0b080c797dbbfac80
#: ../../scala/extending-akka.rst:87
msgid "Use it:"
msgstr ""

# 645e3843fa724f4a8ab9dfa0424c0331
#: ../../scala/fault-tolerance.rst:4
msgid "Fault Tolerance (Scala)"
msgstr ""

# a67b143c2d794fb688cd2cb0a60f88e3
#: ../../scala/fault-tolerance.rst:6
msgid ""
"As explained in :ref:`actor-systems` each actor is the supervisor of its "
"children, and as such each actor defines fault handling supervisor strategy. "
"This strategy cannot be changed afterwards as it is an integral part of the "
"actor system’s structure."
msgstr ""

# 6c1b01a5e0874f28b18dab756bbc324a
#: ../../scala/fault-tolerance.rst:12
msgid "Fault Handling in Practice"
msgstr ""

# 1e87236880cc42e292d8a05cb7a67b53
#: ../../scala/fault-tolerance.rst:14
msgid ""
"First, let us look at a sample that illustrates one way to handle data store "
"errors, which is a typical source of failure in real world applications. Of "
"course it depends on the actual application what is possible to do when the "
"data store is unavailable, but in this sample we use a best effort re-"
"connect approach."
msgstr ""

# 4a82dfa98bf54ca9af417f5b65b903ed
#: ../../scala/fault-tolerance.rst:19
msgid ""
"Read the following source code. The inlined comments explain the different "
"pieces of the fault handling and why they are added. It is also highly "
"recommended to run this sample as it is easy to follow the log output to "
"understand what is happening in runtime."
msgstr ""

# c4e788d2c90947e18fd592fce8f2f884
#: ../../scala/fault-tolerance.rst:31
msgid "Creating a Supervisor Strategy"
msgstr ""

# b0c8841cc4644f8687ec57e40b7349a4
#: ../../scala/fault-tolerance.rst:33
msgid ""
"The following sections explain the fault handling mechanism and alternatives "
"in more depth."
msgstr ""

# 214fed46c5b0415fbc7b16f2500d7e1c
#: ../../scala/fault-tolerance.rst:36
msgid "For the sake of demonstration let us consider the following strategy:"
msgstr ""

# c2b1dcaa560a4db09320cfa01f4d0b76
#: ../../scala/fault-tolerance.rst:41
msgid ""
"I have chosen a few well-known exception types in order to demonstrate the "
"application of the fault handling directives described in :ref:"
"`supervision`. First off, it is a one-for-one strategy, meaning that each "
"child is treated separately (an all-for-one strategy works very similarly, "
"the only difference is that any decision is applied to all children of the "
"supervisor, not only the failing one). There are limits set on the restart "
"frequency, namely maximum 10 restarts per minute; each of these settings "
"could be left out, which means that the respective limit does not apply, "
"leaving the possibility to specify an absolute upper limit on the restarts "
"or to make the restarts work infinitely."
msgstr ""

# 1cd8fc13c88d4e8cabc25e4eb56a0d8b
#: ../../scala/fault-tolerance.rst:51
msgid ""
"The match statement which forms the bulk of the body is of type ``Decider``, "
"which is a ``PartialFunction[Throwable, Directive]``. This is the piece "
"which maps child failure types to their corresponding directives."
msgstr ""

# 4297e4477cff4b839d71fc727698097e
#: ../../scala/fault-tolerance.rst:56
msgid "Default Supervisor Strategy"
msgstr ""

# 41bc60b2451945fba3056d02ee02f55b
#: ../../scala/fault-tolerance.rst:58
msgid ""
"``Escalate`` is used if the defined strategy doesn't cover the exception "
"that was thrown."
msgstr ""

# 44a5148def514bd491b02e85fc31fba0
#: ../../scala/fault-tolerance.rst:60
msgid ""
"When the supervisor strategy is not defined for an actor the following "
"exceptions are handled by default:"
msgstr ""

# 02f3554bcf69431cb07224d5f0df9449
#: ../../scala/fault-tolerance.rst:63
msgid "``ActorInitializationException`` will stop the failing child actor"
msgstr ""

# 736ba9b83609411ea9e74b1a7f4924c8
#: ../../scala/fault-tolerance.rst:64
msgid "``ActorKilledException`` will stop the failing child actor"
msgstr ""

# a164b48da876449694beedd0aaebb782
#: ../../scala/fault-tolerance.rst:65
msgid "``Exception`` will restart the failing child actor"
msgstr ""

# bdb564250aab41759272a11f507ee4da
#: ../../scala/fault-tolerance.rst:66
msgid "Other types of ``Throwable`` will be escalated to parent actor"
msgstr ""

# 492f900276974fc9aa0c899e547b6b9d
#: ../../scala/fault-tolerance.rst:68
msgid ""
"If the exception escalate all the way up to the root guardian it will handle "
"it in the same way as the default strategy defined above."
msgstr ""

# 992a0bc278a64360bd47c3b7aaa82017
#: ../../scala/fault-tolerance.rst:73
msgid "Test Application"
msgstr ""

# 4938bbf5205c4c2980a57d5045773198
#: ../../scala/fault-tolerance.rst:75
msgid ""
"The following section shows the effects of the different directives in "
"practice, wherefor a test setup is needed. First off, we need a suitable "
"supervisor:"
msgstr ""

# 8f0eafc4dd8644668a68541c48abe0d0
#: ../../scala/fault-tolerance.rst:81
msgid ""
"This supervisor will be used to create a child, with which we can experiment:"
msgstr ""

# 539c05de799a461186e200fea776b90d
#: ../../scala/fault-tolerance.rst:86
msgid ""
"The test is easier by using the utilities described in :ref:`akka-testkit`, "
"where ``AkkaSpec`` is a convenient mixture of ``TestKit with WordSpec with "
"MustMatchers``"
msgstr ""

# cf9d4a818fa549cabffc66db2ed3524a
#: ../../scala/fault-tolerance.rst:93
msgid "Let us create actors:"
msgstr ""

# cec0850cc9b240b9b7491bbb6641ad17
#: ../../scala/fault-tolerance.rst:98
msgid ""
"The first test shall demonstrate the ``Resume`` directive, so we try it out "
"by setting some non-initial state in the actor and have it fail:"
msgstr ""

# c125b59d55474c9e9b63b86c099058f8
#: ../../scala/fault-tolerance.rst:104
msgid ""
"As you can see the value 42 survives the fault handling directive. Now, if "
"we change the failure to a more serious ``NullPointerException``, that will "
"no longer be the case:"
msgstr ""

# 2fdbb7e61bfc49acbaa1a0fc3302769a
#: ../../scala/fault-tolerance.rst:111
msgid ""
"And finally in case of the fatal ``IllegalArgumentException`` the child will "
"be terminated by the supervisor:"
msgstr ""

# 510635c50d6744529fdd5f8eedd78dd8
#: ../../scala/fault-tolerance.rst:117
msgid ""
"Up to now the supervisor was completely unaffected by the child’s failure, "
"because the directives set did handle it. In case of an ``Exception``, this "
"is not true anymore and the supervisor escalates the failure."
msgstr ""

# 0ad180d242af403c8e448de43268b23e
#: ../../scala/fault-tolerance.rst:124
msgid ""
"The supervisor itself is supervised by the top-level actor provided by the :"
"class:`ActorSystem`, which has the default policy to restart in case of all "
"``Exception`` cases (with the notable exceptions of "
"``ActorInitializationException`` and ``ActorKilledException``). Since the "
"default directive in case of a restart is to kill all children, we expected "
"our poor child not to survive this failure."
msgstr ""

# 1de35b0621d7484283a5df6df52d5a31
#: ../../scala/fault-tolerance.rst:131
msgid ""
"In case this is not desired (which depends on the use case), we need to use "
"a different supervisor which overrides this behavior."
msgstr ""

# 628f1478473b4d63adcfcf40906c6657
#: ../../scala/fault-tolerance.rst:137
msgid ""
"With this parent, the child survives the escalated restart, as demonstrated "
"in the last test:"
msgstr ""

# 82d1428a4e1540e0a69aa81e09056115
#: ../../scala/fault-tolerance-sample.rst:4
msgid "Diagrams of the Fault Tolerance Sample (Scala)"
msgstr ""

# d9cbb313c61b421f98e970b6dd846734
#: ../../scala/fault-tolerance-sample.rst:10
msgid "*The above diagram illustrates the normal message flow.*"
msgstr ""

# 2ed0b6faf56d410880664238ba042543
#: ../../scala/fault-tolerance-sample.rst:12
msgid "**Normal flow:**"
msgstr ""

# 91449763b35e428d93740e9749a16124
# e9211620dc134132b4b3644c9d438b44
#: ../../scala/fault-tolerance-sample.rst:15
#: ../../scala/fault-tolerance-sample.rst:35
msgid "Step"
msgstr ""

# a521756a1783415489d5c015c2cc09ef
# d78ce48632864f148f9d50987b743c0b
#: ../../scala/fault-tolerance-sample.rst:17
#: ../../scala/fault-tolerance-sample.rst:37
msgid "1"
msgstr ""

# 198a6438ec6242fcb29fb2df8f002be1
#: ../../scala/fault-tolerance-sample.rst:17
msgid "The progress ``Listener`` starts the work."
msgstr ""

# cdd94b341d0242879467208c046ef39a
# 7be34fe80dc94948a17399d12f3c374f
#: ../../scala/fault-tolerance-sample.rst:18
#: ../../scala/fault-tolerance-sample.rst:38
msgid "2"
msgstr ""

# 975020926b4f4e6da5a2f4cdf64d2f90
#: ../../scala/fault-tolerance-sample.rst:18
msgid ""
"The ``Worker`` schedules work by sending ``Do`` messages periodically to "
"itself"
msgstr ""

# 1a29066574ba4b7b9cfc59b64204e47b
#: ../../scala/fault-tolerance-sample.rst:19
msgid "3, 4, 5"
msgstr ""

# 55cf5e3306264ebda5a2407e50a5c97b
#: ../../scala/fault-tolerance-sample.rst:19
msgid ""
"When receiving ``Do`` the ``Worker`` tells the ``CounterService`` to "
"increment the counter, three times. The ``Increment`` message is forwarded "
"to the ``Counter``, which updates its counter variable and sends current "
"value to the ``Storage``."
msgstr ""

# d129b106e9d74f2d9ddb76b6c24db55c
#: ../../scala/fault-tolerance-sample.rst:23
msgid "6, 7"
msgstr ""

# 37b8023f48cc4d4f9b0e96e42b8ecb5f
#: ../../scala/fault-tolerance-sample.rst:23
msgid ""
"The ``Worker`` asks the ``CounterService`` of current value of the counter "
"and pipes the result back to the ``Listener``."
msgstr ""

# 56ce956cc73c47cf8ea03bb975cf6174
#: ../../scala/fault-tolerance-sample.rst:30
msgid ""
"*The above diagram illustrates what happens in case of storage failure.*"
msgstr ""

# 943e58ac16fe40adace842fdb35f680d
#: ../../scala/fault-tolerance-sample.rst:32
msgid "**Failure flow:**"
msgstr ""

# aa37bfb3aedf4464bdcde3e53983e982
#: ../../scala/fault-tolerance-sample.rst:37
msgid "The ``Storage`` throws ``StorageException``."
msgstr ""

# 450b43033ddd49058e69f8996405f52c
#: ../../scala/fault-tolerance-sample.rst:38
msgid ""
"The ``CounterService`` is supervisor of the ``Storage`` and restarts the "
"``Storage`` when ``StorageException`` is thrown."
msgstr ""

# d3ec9ed950024d328c61e7fac24102e3
#: ../../scala/fault-tolerance-sample.rst:40
msgid "3, 4, 5, 6"
msgstr ""

# 5c37df06739c458b960354e49f0d475c
#: ../../scala/fault-tolerance-sample.rst:40
msgid "The ``Storage`` continues to fail and is restarted."
msgstr ""

# 5cd4665f9b234ba89ac7fd62565d9a2c
#: ../../scala/fault-tolerance-sample.rst:41
msgid "7"
msgstr ""

# c103e5d3e76c497599504e5ed7a66979
#: ../../scala/fault-tolerance-sample.rst:41
msgid ""
"After 3 failures and restarts within 5 seconds the ``Storage`` is stopped by "
"its supervisor, i.e. the ``CounterService``."
msgstr ""

# b748e3ece59c4b12a745e00c5095e3d5
#: ../../scala/fault-tolerance-sample.rst:43
msgid "8"
msgstr ""

# 61d1a7566828415d8c444bac66714fc0
#: ../../scala/fault-tolerance-sample.rst:43
msgid ""
"The ``CounterService`` is also watching the ``Storage`` for termination and "
"receives the ``Terminated`` message when the ``Storage`` has been stopped ..."
msgstr ""

# c94fed6c8a37447cbcd2479e3aeebc60
#: ../../scala/fault-tolerance-sample.rst:45
msgid "9, 10, 11"
msgstr ""

# 39cb2c60d2d341d69737b2f1a04ad0f8
#: ../../scala/fault-tolerance-sample.rst:45
msgid "and tells the ``Counter`` that there is no ``Storage``."
msgstr ""

# 26d09953fb8e497f97f5d3ec0580da85
#: ../../scala/fault-tolerance-sample.rst:46
msgid "12"
msgstr ""

# 8c2d941138234913bb07741e958ea74f
#: ../../scala/fault-tolerance-sample.rst:46
msgid "The ``CounterService`` schedules a ``Reconnect`` message to itself."
msgstr ""

# 889aa2f8805349698fabcd5e4650784c
#: ../../scala/fault-tolerance-sample.rst:47
msgid "13, 14"
msgstr ""

# ec6b242e7e244f0fb16ad38ff4093390
#: ../../scala/fault-tolerance-sample.rst:47
msgid ""
"When it receives the ``Reconnect`` message it creates a new ``Storage`` ..."
msgstr ""

# 6618bd58d2de41e2ac6fbacbe6ef05ec
#: ../../scala/fault-tolerance-sample.rst:48
msgid "15, 16"
msgstr ""

# 00ec97d395004324b7fbf7af7da5fdc2
#: ../../scala/fault-tolerance-sample.rst:48
msgid "and tells the the ``Counter`` to use the new ``Storage``"
msgstr ""

# fc818f0af56d468aa51790e4635ebea3
#: ../../scala/fault-tolerance-sample.rst:52
msgid "Full Source Code of the Fault Tolerance Sample (Scala)"
msgstr ""

# 1d8011d7be784571ad49b5b3b0a546e3
#: ../../scala/fsm.rst:5
msgid "FSM"
msgstr ""

# 5c79186e4ae9420885b4d428bdba3b75
#: ../../scala/fsm.rst:9
msgid "Overview"
msgstr ""

# 461e607c9f464edc833bf3d9ba2bafe5
#: ../../scala/fsm.rst:11
msgid ""
"The FSM (Finite State Machine) is available as a mixin for the akka Actor "
"and is best described in the `Erlang design principles <http://www.erlang."
"org/documentation/doc-4.8.2/doc/design_principles/fsm.html>`_"
msgstr ""

# 3fe5d2f21ec8493ba27dce9f45a707db
#: ../../scala/fsm.rst:15
msgid "A FSM can be described as a set of relations of the form:"
msgstr ""

# af76299e7de746e6bc4595e0c9a57e3a
#: ../../scala/fsm.rst:17
msgid "**State(S) x Event(E) -> Actions (A), State(S')**"
msgstr ""

# 411efed15f244fb8b7a662367bb8bf01
#: ../../scala/fsm.rst:19
msgid "These relations are interpreted as meaning:"
msgstr ""

# 0d784a66c1ef4c0b89175b78fb53c4f4
#: ../../scala/fsm.rst:21
msgid ""
"*If we are in state S and the event E occurs, we should perform the actions "
"A and make a transition to the state S'.*"
msgstr ""

# e1b7b929414743cea4d3ef9828dbd1ba
#: ../../scala/fsm.rst:25
msgid "A Simple Example"
msgstr ""

# 4531411415a94fd98487d584ad49d6e0
#: ../../scala/fsm.rst:27
msgid ""
"To demonstrate most of the features of the :class:`FSM` trait, consider an "
"actor which shall receive and queue messages while they arrive in a burst "
"and send them on after the burst ended or a flush request is received."
msgstr ""

# e72a1a1a3b154e2b82e6cc641d768d72
#: ../../scala/fsm.rst:31
msgid "First, consider all of the below to use these import statements:"
msgstr ""

# 48d6cf1db1204307a65f9b863bd52943
#: ../../scala/fsm.rst:35
msgid ""
"The contract of our “Buncher” actor is that is accepts or produces the "
"following messages:"
msgstr ""

# 7e6e2373a9cf4814a6d76c8c0bfe5675
#: ../../scala/fsm.rst:39
msgid ""
"``SetTarget`` is needed for starting it up, setting the destination for the "
"``Batches`` to be passed on; ``Queue`` will add to the internal queue while "
"``Flush`` will mark the end of a burst."
msgstr ""

# 75e082403c174bc9b1557f64b85956bd
#: ../../scala/fsm.rst:45
msgid ""
"The actor can be in two states: no message queued (aka ``Idle``) or some "
"message queued (aka ``Active``). It will stay in the active state as long as "
"messages keep arriving and no flush is requested. The internal state data of "
"the actor is made up of the target actor reference to send the batches to "
"and the actual queue of messages."
msgstr ""

# 1b361c6b24a34070bb8d3b7455b9b84e
#: ../../scala/fsm.rst:51
msgid "Now let’s take a look at the skeleton for our FSM actor:"
msgstr ""

# e090430478c24fffbb1902b1ed5a41e8
#: ../../scala/fsm.rst:57
msgid ""
"The basic strategy is to declare the actor, mixing in the :class:`FSM` trait "
"and specifying the possible states and data values as type parameters. "
"Within the body of the actor a DSL is used for declaring the state machine:"
msgstr ""

# 9521d51a10dd40eb88332bcf67833e31
#: ../../scala/fsm.rst:61
msgid ":meth:`startsWith` defines the initial state and initial data"
msgstr ""

# e722ea4d2979448e8b762a4f17f437dd
#: ../../scala/fsm.rst:62
msgid ""
"then there is one :meth:`when(<state>) { ... }` declaration per state to be "
"handled (could potentially be multiple ones, the passed :class:"
"`PartialFunction` will be concatenated using :meth:`orElse`)"
msgstr ""

# 2fc6cb3668f243e793561c6ff47ccc1d
#: ../../scala/fsm.rst:65
msgid ""
"finally starting it up using :meth:`initialize`, which performs the "
"transition into the initial state and sets up timers (if required)."
msgstr ""

# b13fcf768757427ca8d75b7f02c3db56
#: ../../scala/fsm.rst:68
msgid ""
"In this case, we start out in the ``Idle`` and ``Uninitialized`` state, "
"where only the ``SetTarget()`` message is handled; ``stay`` prepares to end "
"this event’s processing for not leaving the current state, while the "
"``using`` modifier makes the FSM replace the internal state (which is "
"``Uninitialized`` at this point) with a fresh ``Todo()`` object containing "
"the target actor reference. The ``Active`` state has a state timeout "
"declared, which means that if no message is received for 1 second, a ``FSM."
"StateTimeout`` message will be generated. This has the same effect as "
"receiving the ``Flush`` command in this case, namely to transition back into "
"the ``Idle`` state and resetting the internal queue to the empty vector. But "
"how do messages get queued? Since this shall work identically in both "
"states, we make use of the fact that any event which is not handled by the "
"``when()`` block is passed to the ``whenUnhandled()`` block:"
msgstr ""

# 943db149c1ed48e7bb069658a4b0cdac
#: ../../scala/fsm.rst:84
msgid ""
"The first case handled here is adding ``Queue()`` requests to the internal "
"queue and going to the ``Active`` state (this does the obvious thing of "
"staying in the ``Active`` state if already there), but only if the FSM data "
"are not ``Uninitialized`` when the ``Queue()`` event is received. Otherwise—"
"and in all other non-handled cases—the second case just logs a warning and "
"does not change the internal state."
msgstr ""

# d0a47fc8b0ac45548a0c8ff3aaabd202
#: ../../scala/fsm.rst:91
msgid ""
"The only missing piece is where the ``Batches`` are actually sent to the "
"target, for which we use the ``onTransition`` mechanism: you can declare "
"multiple such blocks and all of them will be tried for matching behavior in "
"case a state transition occurs (i.e. only when the state actually changes)."
msgstr ""

# f86a7c80048243dd80f7d5bf1c0ae72d
#: ../../scala/fsm.rst:98
msgid ""
"The transition callback is a partial function which takes as input a pair of "
"states—the current and the next state. The FSM trait includes a convenience "
"extractor for these in form of an arrow operator, which conveniently reminds "
"you of the direction of the state change which is being matched. During the "
"state change, the old state data is available via ``stateData`` as shown, "
"and the new state data would be available as ``nextStateData``."
msgstr ""

# 8a919dbe2d3041d599578a0fd2adc1f7
#: ../../scala/fsm.rst:105
msgid ""
"To verify that this buncher actually works, it is quite easy to write a test "
"using the :ref:`akka-testkit`, which is conveniently bundled with ScalaTest "
"traits into ``AkkaSpec``:"
msgstr ""

# 36831d1350524025990d954c184cb76e
#: ../../scala/fsm.rst:114
msgid "Reference"
msgstr ""

# a8cb1d870a2e4b6d8fce5afec8cfbd9a
#: ../../scala/fsm.rst:117
msgid "The FSM Trait and Object"
msgstr ""

# e17c55987be8487194046e724f71cc27
#: ../../scala/fsm.rst:119
msgid ""
"The :class:`FSM` trait may only be mixed into an :class:`Actor`. Instead of "
"extending :class:`Actor`, the self type approach was chosen in order to make "
"it obvious that an actor is actually created.  Importing all members of the :"
"obj:`FSM` object is recommended if you want to directly access the symbols "
"like :obj:`StateTimeout`. This import is usually placed inside the state "
"machine definition:"
msgstr ""

# 4a913bc786694d2a8ea46d819be87c65
#: ../../scala/fsm.rst:135
msgid "The :class:`FSM` trait takes two type parameters:"
msgstr ""

# 63485c00b63243dd850b0b094f09cf45
#: ../../scala/fsm.rst:137
msgid ""
"the supertype of all state names, usually a sealed trait with case objects "
"extending it,"
msgstr ""

# eb3be2677ab54ad3b35ba4bf4d65731a
#: ../../scala/fsm.rst:139
msgid ""
"the type of the state data which are tracked by the :class:`FSM` module "
"itself."
msgstr ""

# 25a9811fd488458daff0d0af4dfa46fb
#: ../../scala/fsm.rst:146
msgid ""
"The state data together with the state name describe the internal state of "
"the state machine; if you stick to this scheme and do not add mutable fields "
"to the FSM class you have the advantage of making all changes of the "
"internal state explicit in a few well-known places."
msgstr ""

# 3fba26b2f8ab4a6b8e89b925d0072999
#: ../../scala/fsm.rst:152
msgid "Defining States"
msgstr ""

# 38e7e17cd7fc407ea74f49ecb38284ca
#: ../../scala/fsm.rst:154
msgid "A state is defined by one or more invocations of the method"
msgstr ""

# 7ae6caf81d4b494ba474d001a5a8e88e
#: ../../scala/fsm.rst:156
msgid ":func:`when(<name>[, stateTimeout = <timeout>])(stateFunction)`."
msgstr ""

# 4ede31c1428b43459227403438371eff
#: ../../scala/fsm.rst:158
msgid ""
"The given name must be an object which is type-compatible with the first "
"type parameter given to the :class:`FSM` trait. This object is used as a "
"hash key, so you must ensure that it properly implements :meth:`equals` and :"
"meth:`hashCode`; in particular it must not be mutable. The easiest fit for "
"these requirements are case objects."
msgstr ""

# 0d20527383ef485baa2eaf5a8b77d22d
#: ../../scala/fsm.rst:164
msgid ""
"If the :meth:`stateTimeout` parameter is given, then all transitions into "
"this state, including staying, receive this timeout by default. Initiating "
"the transition with an explicit timeout may be used to override this "
"default, see `Initiating Transitions`_ for more information. The state "
"timeout of any state may be changed during action processing with :func:"
"`setStateTimeout(state, duration)`. This enables runtime configuration e.g. "
"via external message."
msgstr ""

# 8a573575b096479ba070150ea2f196df
#: ../../scala/fsm.rst:171
msgid ""
"The :meth:`stateFunction` argument is a :class:`PartialFunction[Event, State]"
"`, which is conveniently given using the partial function literal syntax as "
"demonstrated below:"
msgstr ""

# 94d4c0eae66949d5895ea3713d6661d0
#: ../../scala/fsm.rst:188
msgid ""
"The :class:`Event(msg: Any, data: D)` case class is parameterized with the "
"data type held by the FSM for convenient pattern matching."
msgstr ""

# 9112c5bd62d4411d979d27deb1f1e6a2
#: ../../scala/fsm.rst:192
msgid "Defining the Initial State"
msgstr ""

# 2b51b1180a634aa594339752b43844f7
#: ../../scala/fsm.rst:194
msgid "Each FSM needs a starting point, which is declared using"
msgstr ""

# 5a2e6e6ef0cc4d4dbcc20ab5014da856
#: ../../scala/fsm.rst:196
msgid ":func:`startWith(state, data[, timeout])`"
msgstr ""

# 4d6d610d26514978a815098ca04accaa
#: ../../scala/fsm.rst:198
msgid ""
"The optionally given timeout argument overrides any specification given for "
"the desired initial state. If you want to cancel a default timeout, use :obj:"
"`Duration.Inf`."
msgstr ""

# e17703c165d041e2b6059d430e602b1b
#: ../../scala/fsm.rst:203
msgid "Unhandled Events"
msgstr ""

# 9db3bbf95cb84f8290681a76534b5d5e
#: ../../scala/fsm.rst:205
msgid ""
"If a state doesn't handle a received event a warning is logged. If you want "
"to do something else in this case you can specify that with :func:"
"`whenUnhandled(stateFunction)`:"
msgstr ""

# 4fa1df7aaf6e4a8d89478fa6bfbb2667
#: ../../scala/fsm.rst:220
msgid ""
"**IMPORTANT**: This handler is not stacked, meaning that each invocation of :"
"func:`whenUnhandled` replaces the previously installed handler."
msgstr ""

# 41322d88161d461db7ee93e16043a739
#: ../../scala/fsm.rst:224
msgid "Initiating Transitions"
msgstr ""

# 6db3bb1be63840c3aa206b2fb7126a0b
#: ../../scala/fsm.rst:226
msgid ""
"The result of any :obj:`stateFunction` must be a definition of the next "
"state unless terminating the FSM, which is described in `Termination from "
"Inside`_. The state definition can either be the current state, as described "
"by the :func:`stay` directive, or it is a different state as given by :func:"
"`goto(state)`. The resulting object allows further qualification by way of "
"the modifiers described in the following:"
msgstr ""

# 963de40ccf1f4c9f909653a1b5a1de27
#: ../../scala/fsm.rst:234
msgid ""
"This modifier sets a state timeout on the next state. This means that a "
"timer is started which upon expiry sends a :obj:`StateTimeout` message to "
"the FSM. This timer is canceled upon reception of any other message in the "
"meantime; you can rely on the fact that the :obj:`StateTimeout` message will "
"not be processed after an intervening message."
msgstr ""

# 74e8c30dd52347698b860585b7755bee
#: ../../scala/fsm.rst:240
msgid ""
"This modifier can also be used to override any default timeout which is "
"specified for the target state. If you want to cancel the default timeout, "
"use :obj:`Duration.Inf`."
msgstr ""

# 1e77fd2a429e4031bfec3c5966dfad6c
#: ../../scala/fsm.rst:245
msgid ""
"This modifier replaces the old state data with the new data given. If you "
"follow the advice :ref:`above <fsm-philosophy>`, this is the only place "
"where internal state data are ever modified."
msgstr ""

# 0164e684724b428fa31f1761a86cf95a
#: ../../scala/fsm.rst:250
msgid ""
"This modifier sends a reply to the currently processed message and otherwise "
"does not modify the state transition."
msgstr ""

# 5413f66937dd44ea9988ed605a5b1d9b
#: ../../scala/fsm.rst:253
msgid "All modifier can be chained to achieve a nice and concise description:"
msgstr ""

# 4c2b0fe5f9c8454fb142db289cfaf349
#: ../../scala/fsm.rst:262
msgid ""
"The parentheses are not actually needed in all cases, but they visually "
"distinguish between modifiers and their arguments and therefore make the "
"code even more pleasant to read for foreigners."
msgstr ""

# 62265ea5baee4760a8c9f7367a188c1b
#: ../../scala/fsm.rst:268
msgid ""
"Please note that the ``return`` statement may not be used in :meth:`when` "
"blocks or similar; this is a Scala restriction. Either refactor your code "
"using ``if () ... else ...`` or move it into a method definition."
msgstr ""

# 5446709a397a47c4bad8613e5cdfd6e8
#: ../../scala/fsm.rst:273
msgid "Monitoring Transitions"
msgstr ""

# 45325182837e4349b56941c04d773148
#: ../../scala/fsm.rst:275
msgid ""
"Transitions occur \"between states\" conceptually, which means after any "
"actions you have put into the event handling block; this is obvious since "
"the next state is only defined by the value returned by the event handling "
"logic. You do not need to worry about the exact order with respect to "
"setting the internal state variable, as everything within the FSM actor is "
"running single-threaded anyway."
msgstr ""

# a2c06adb6cbb490999e29bd86b5168d3
#: ../../scala/fsm.rst:283
msgid "Internal Monitoring"
msgstr ""

# b3e90b672a2045ff90018ff7a0277c90
#: ../../scala/fsm.rst:285
msgid ""
"Up to this point, the FSM DSL has been centered on states and events. The "
"dual view is to describe it as a series of transitions. This is enabled by "
"the method"
msgstr ""

# 50b767b4b86a4cc19e0355b45d98889d
#: ../../scala/fsm.rst:289
msgid ":func:`onTransition(handler)`"
msgstr ""

# ebbd47ba244548318e8aa37435f646ef
#: ../../scala/fsm.rst:291
msgid ""
"which associates actions with a transition instead of with a state and "
"event. The handler is a partial function which takes a pair of states as "
"input; no resulting state is needed as it is not possible to modify the "
"transition in progress."
msgstr ""

# e1037cdd418c4b9a8897f1a9b6e59780
#: ../../scala/fsm.rst:304
msgid ""
"The convenience extractor :obj:`->` enables decomposition of the pair of "
"states with a clear visual reminder of the transition's direction. As usual "
"in pattern matches, an underscore may be used for irrelevant parts; "
"alternatively you could bind the unconstrained state to a variable, e.g. for "
"logging as shown in the last case."
msgstr ""

# 41779505ce204b9a8398e3e9bd224bdc
#: ../../scala/fsm.rst:310
msgid ""
"It is also possible to pass a function object accepting two states to :func:"
"`onTransition`, in case your transition handling logic is implemented as a "
"method:"
msgstr ""

# bd8ee232a1324d6db41071c6f6dde512
#: ../../scala/fsm.rst:322
msgid ""
"The handlers registered with this method are stacked, so you can "
"intersperse :func:`onTransition` blocks with :func:`when` blocks as suits "
"your design. It should be noted, however, that *all handlers will be invoked "
"for each transition*, not only the first matching one. This is designed "
"specifically so you can put all transition handling for a certain aspect "
"into one place without having to worry about earlier declarations shadowing "
"later ones; the actions are still executed in declaration order, though."
msgstr ""

# 4f9f01b5cda94cf39b3224664c79e922
#: ../../scala/fsm.rst:332
msgid ""
"This kind of internal monitoring may be used to structure your FSM according "
"to transitions, so that for example the cancellation of a timer upon leaving "
"a certain state cannot be forgot when adding new target states."
msgstr ""

# 200e40277b184738b0ffa5b7c4635efb
#: ../../scala/fsm.rst:337
msgid "External Monitoring"
msgstr ""

# b9132f3d53b5420f81ad4834ed8391a2
#: ../../scala/fsm.rst:339
msgid ""
"External actors may be registered to be notified of state transitions by "
"sending a message :class:`SubscribeTransitionCallBack(actorRef)`. The named "
"actor will be sent a :class:`CurrentState(self, stateName)` message "
"immediately and will receive :class:`Transition(actorRef, oldState, newState)"
"` messages whenever a new state is reached. External monitors may be "
"unregistered by sending :class:`UnsubscribeTransitionCallBack(actorRef)` to "
"the FSM actor."
msgstr ""

# 3456dadc18fe4618955b977b75a946ae
#: ../../scala/fsm.rst:346
msgid ""
"Registering a not-running listener generates a warning and fails gracefully. "
"Stopping a listener without unregistering will remove the listener from the "
"subscription list upon the next transition."
msgstr ""

# ceec41729a334137bc278667eded2071
#: ../../scala/fsm.rst:351
msgid "Timers"
msgstr ""

# 7cac4e7a9bfd4a599436b3b1cb626466
#: ../../scala/fsm.rst:353
msgid ""
"Besides state timeouts, FSM manages timers identified by :class:`String` "
"names. You may set a timer using"
msgstr ""

# c4bf8e2b702d428c876a5fb01813415d
#: ../../scala/fsm.rst:356
msgid ":func:`setTimer(name, msg, interval, repeat)`"
msgstr ""

# 4365ee871ec44dc09c2a84100fe39595
#: ../../scala/fsm.rst:358
msgid ""
"where :obj:`msg` is the message object which will be sent after the "
"duration :obj:`interval` has elapsed. If :obj:`repeat` is :obj:`true`, then "
"the timer is scheduled at fixed rate given by the :obj:`interval` parameter. "
"Timers may be canceled using"
msgstr ""

# 390b6b1dd94e4fd7b1e5a7cb343a7711
#: ../../scala/fsm.rst:363
msgid ":func:`cancelTimer(name)`"
msgstr ""

# f1ecae91f6b848bb9fe4c96dc43dc5c3
#: ../../scala/fsm.rst:365
msgid ""
"which is guaranteed to work immediately, meaning that the scheduled message "
"will not be processed after this call even if the timer already fired and "
"queued it. The status of any timer may be inquired with"
msgstr ""

# dcc535884069465aa1fc6d03e578fe04
#: ../../scala/fsm.rst:369
msgid ":func:`timerActive_?(name)`"
msgstr ""

# 4c4a3fa802424bf48ded9cd4e2247c19
#: ../../scala/fsm.rst:371
msgid ""
"These named timers complement state timeouts because they are not affected "
"by intervening reception of other messages."
msgstr ""

# 13a1f8b012df44bc9a951c333a237397
#: ../../scala/fsm.rst:375
msgid "Termination from Inside"
msgstr ""

# 34aa299de1eb4d848c9852ef6f547bcb
#: ../../scala/fsm.rst:377
msgid "The FSM is stopped by specifying the result state as"
msgstr ""

# fe335b17c8614e8f8761cf1768aa6531
#: ../../scala/fsm.rst:379
msgid ":func:`stop([reason[, data]])`"
msgstr ""

# 404a9c47a2d542419b8194ddc4d24803
#: ../../scala/fsm.rst:381
msgid ""
"The reason must be one of :obj:`Normal` (which is the default), :obj:"
"`Shutdown` or :obj:`Failure(reason)`, and the second argument may be given "
"to change the state data which is available during termination handling."
msgstr ""

# 58aa088ad6d9483a851ce982fd0dc4af
#: ../../scala/fsm.rst:387
msgid ""
"It should be noted that :func:`stop` does not abort the actions and stop the "
"FSM immediately. The stop action must be returned from the event handler in "
"the same way as a state transition (but note that the ``return`` statement "
"may not be used within a :meth:`when` block)."
msgstr ""

# 0a4ac0cf4174458e9686e39c76422604
#: ../../scala/fsm.rst:400
msgid ""
"You can use :func:`onTermination(handler)` to specify custom code that is "
"executed when the FSM is stopped. The handler is a partial function which "
"takes a :class:`StopEvent(reason, stateName, stateData)` as argument:"
msgstr ""

# f15685f525244715bfeda3db0166af8d
#: ../../scala/fsm.rst:412
msgid ""
"As for the :func:`whenUnhandled` case, this handler is not stacked, so each "
"invocation of :func:`onTermination` replaces the previously installed "
"handler."
msgstr ""

# c94d4007c13445e2914655d9b363f57e
#: ../../scala/fsm.rst:416
msgid "Termination from Outside"
msgstr ""

# f6871e19be554897882ba18a54b12578
#: ../../scala/fsm.rst:418
msgid ""
"When an :class:`ActorRef` associated to a FSM is stopped using the :meth:"
"`stop()` method, its :meth:`postStop` hook will be executed. The default "
"implementation by the :class:`FSM` trait is to execute the :meth:"
"`onTermination` handler if that is prepared to handle a :obj:`StopEvent"
"(Shutdown, ...)`."
msgstr ""

# 8290a025000b466e801778c3718987de
#: ../../scala/fsm.rst:426
msgid ""
"In case you override :meth:`postStop` and want to have your :meth:"
"`onTermination` handler called, do not forget to call ``super.postStop``."
msgstr ""

# f41228ffd7854530b179c05cf609f892
#: ../../scala/fsm.rst:431
msgid "Testing and Debugging Finite State Machines"
msgstr ""

# 357e24b5068e4769a71e515cae67a79b
#: ../../scala/fsm.rst:433
msgid ""
"During development and for trouble shooting FSMs need care just as any other "
"actor. There are specialized tools available as described in :ref:"
"`TestFSMRef` and in the following."
msgstr ""

# 3d485c3cc04c444b931fc2788a546049
#: ../../scala/fsm.rst:438
msgid "Event Tracing"
msgstr ""

# 13d5e4051ff34be697f5bae4f8d9948f
#: ../../scala/fsm.rst:440
msgid ""
"The setting ``akka.actor.debug.fsm`` in `:ref:`configuration` enables "
"logging of an event trace by :class:`LoggingFSM` instances::"
msgstr ""

# eace10e393d54406be65670dfd42c6d7
#: ../../scala/fsm.rst:447
msgid "This FSM will log at DEBUG level:"
msgstr ""

# 53c6d9d0a28649b8bb0ed23a850b8924
#: ../../scala/fsm.rst:449
msgid ""
"all processed events, including :obj:`StateTimeout` and scheduled timer "
"messages"
msgstr ""

# 647d5e824b7b422ca7a201929ef6d955
#: ../../scala/fsm.rst:451
msgid "every setting and cancellation of named timers"
msgstr ""

# c4e3b3138a904bd684bbc945619a4a82
#: ../../scala/fsm.rst:452
msgid "all state transitions"
msgstr ""

# ed3a0cbf39ed4a1cb7e00540f816f1a6
#: ../../scala/fsm.rst:454
msgid ""
"Life cycle changes and special messages can be logged as described for :ref:"
"`Actors <actor.logging>`."
msgstr ""

# b7992e634da44e6086fdc7fdf0274a92
#: ../../scala/fsm.rst:458
msgid "Rolling Event Log"
msgstr ""

# df78e46535f94a30b0e22c380f4a4c8f
#: ../../scala/fsm.rst:460
msgid ""
"The :class:`LoggingFSM` trait adds one more feature to the FSM: a rolling "
"event log which may be used during debugging (for tracing how the FSM "
"entered a certain failure state) or for other creative uses::"
msgstr ""

# d779c78a23c2409ba286cbb4c5fe41a4
#: ../../scala/fsm.rst:474
msgid "The :meth:`logDepth` defaults to zero, which turns off the event log."
msgstr ""

# 8b731d9d30de4955964a342ddda9bc8d
#: ../../scala/fsm.rst:478
msgid ""
"The log buffer is allocated during actor creation, which is why the "
"configuration is done using a virtual method call. If you want to override "
"with a ``val``, make sure that its initialization happens before the "
"initializer of :class:`LoggingFSM` runs, and do not change the value "
"returned by ``logDepth`` after the buffer has been allocated."
msgstr ""

# 1ba478cc30fd40888fad0f5dcef6fceb
#: ../../scala/fsm.rst:484
msgid ""
"The contents of the event log are available using method :meth:`getLog`, "
"which returns an :class:`IndexedSeq[LogEntry]` where the oldest entry is at "
"index zero."
msgstr ""

# 9870fbbc24fb4cb3af6e12f46e250669
#: ../../scala/fsm.rst:491
msgid ""
"A bigger FSM example contrasted with Actor's :meth:`become`/:meth:`unbecome` "
"can be found in the sources:"
msgstr ""

# e1e196f261e54f95b3978c86606dc305
#: ../../scala/fsm.rst:493
msgid ""
"`Dining Hakkers using FSM <https://github.com/akka/akka/blob/master/akka-"
"samples/akka-sample-fsm/src/main/scala/DiningHakkersOnFsm.scala#L1>`_"
msgstr ""

# 0f4c7c6dfb544a37b929ff95893b80e7
#: ../../scala/fsm.rst:494
msgid ""
"`Dining Hakkers using become <https://github.com/akka/akka/blob/master/akka-"
"samples/akka-sample-fsm/src/main/scala/DiningHakkersOnBecome.scala#L1>`_"
msgstr ""

# efcba011680241ec815cc851d459a41f
#: ../../scala/futures.rst:4
msgid "Futures (Scala)"
msgstr ""

# 5ea5b29df8994cafa48f011f7c249bc2
# a161ef51add1426086c6f511fdc97ae5
#: ../../scala/futures.rst:8 ../../scala/io.rst:8
msgid "Introduction"
msgstr ""

# 01726c30025741e5a1eba0bc5cca97a7
#: ../../scala/futures.rst:10
msgid ""
"In Akka, a `Future <http://en.wikipedia.org/wiki/Futures_and_promises>`_ is "
"a data structure used to retrieve the result of some concurrent operation. "
"This operation is usually performed by an ``Actor`` or by the ``Dispatcher`` "
"directly. This result can be accessed synchronously (blocking) or "
"asynchronously (non-blocking)."
msgstr ""

# 31eac0c955374ea08c2c13ccdb8c97ce
#: ../../scala/futures.rst:15
msgid "Execution Contexts"
msgstr ""

# f799aa064c3243eb8f40473d4f5807dd
#: ../../scala/futures.rst:17
msgid ""
"In order to execute callbacks and operations, Futures need something called "
"an ``ExecutionContext``, which is very similar to a ``java.util.concurrent."
"Executor``. if you have an ``ActorSystem`` in scope, it will use its default "
"dispatcher as the ``ExecutionContext``, or you can use the factory methods "
"provided by the ``ExecutionContext`` companion object to wrap ``Executors`` "
"and ``ExecutorServices``, or even create your own."
msgstr ""

# e479e1f49dba42deabd603cd2829c579
#: ../../scala/futures.rst:26
msgid "Use With Actors"
msgstr ""

# 41e29c7d46034988bc27848ccb6049df
#: ../../scala/futures.rst:28
msgid ""
"There are generally two ways of getting a reply from an ``Actor``: the first "
"is by a sent message (``actor ! msg``), which only works if the original "
"sender was an ``Actor``) and the second is through a ``Future``."
msgstr ""

# 4ad1af712a0643c4b498ee1c08f420bc
#: ../../scala/futures.rst:31
msgid ""
"Using an ``Actor``\\'s ``?`` method to send a message will return a Future. "
"To wait for and retrieve the actual result the simplest method is:"
msgstr ""

# f13bc9aab2c14295afa49fda5428eb79
#: ../../scala/futures.rst:36
msgid ""
"This will cause the current thread to block and wait for the ``Actor`` to "
"'complete' the ``Future`` with it's reply. Blocking is discouraged though as "
"it will cause performance problems. The blocking operations are located in "
"``Await.result`` and ``Await.ready`` to make it easy to spot where blocking "
"occurs. Alternatives to blocking are discussed further within this "
"documentation. Also note that the ``Future`` returned by an ``Actor`` is a "
"``Future[Any]`` since an ``Actor`` is dynamic. That is why the "
"``asInstanceOf`` is used in the above sample. When using non-blocking it is "
"better to use the ``mapTo`` method to safely try to cast a ``Future`` to an "
"expected type:"
msgstr ""

# 837fe15a303f4d62b57d7209cd587789
#: ../../scala/futures.rst:46
msgid ""
"The ``mapTo`` method will return a new ``Future`` that contains the result "
"if the cast was successful, or a ``ClassCastException`` if not. Handling "
"``Exception``\\s will be discussed further within this documentation."
msgstr ""

# be5e0c8ef3fe47008c0cab3e3d5fad14
#: ../../scala/futures.rst:50
msgid "Use Directly"
msgstr ""

# 14cf5aa5aa1a47d19c12860e115c8b0f
#: ../../scala/futures.rst:52
msgid ""
"A common use case within Akka is to have some computation performed "
"concurrently without needing the extra utility of an ``Actor``. If you find "
"yourself creating a pool of ``Actor``\\s for the sole reason of performing a "
"calculation in parallel, there is an easier (and faster) way:"
msgstr ""

# a7d29f42366c479ca64fd044680b124f
#: ../../scala/futures.rst:59
msgid ""
"In the above code the block passed to ``Future`` will be executed by the "
"default ``Dispatcher``, with the return value of the block used to complete "
"the ``Future`` (in this case, the result would be the string: \"HelloWorld"
"\"). Unlike a ``Future`` that is returned from an ``Actor``, this ``Future`` "
"is properly typed, and we also avoid the overhead of managing an ``Actor``."
msgstr ""

# 2e8d28f381e146aea472c346a3877da8
#: ../../scala/futures.rst:64
msgid ""
"You can also create already completed Futures using the ``Promise`` "
"companion, which can be either successes:"
msgstr ""

# dd4d68d797a646b284efb5abdcc67954
#: ../../scala/futures.rst:69
msgid "Or failures:"
msgstr ""

# 299610c1c7c34e25afb4d8e738c6e29a
#: ../../scala/futures.rst:75
msgid "Functional Futures"
msgstr ""

# d575b041f34d4196ad0bb6a4e8314c69
#: ../../scala/futures.rst:77
msgid ""
"Akka's ``Future`` has several monadic methods that are very similar to the "
"ones used by Scala's collections. These allow you to create 'pipelines' or "
"'streams' that the result will travel through."
msgstr ""

# 2e77d8b2c0274b518aba97b883217dec
#: ../../scala/futures.rst:81
msgid "Future is a Monad"
msgstr ""

# 19e5c45b938f49d785965d690f10cacb
#: ../../scala/futures.rst:83
msgid ""
"The first method for working with ``Future`` functionally is ``map``. This "
"method takes a ``Function`` which performs some operation on the result of "
"the ``Future``, and returning a new result. The return value of the ``map`` "
"method is another ``Future`` that will contain the new result:"
msgstr ""

# b8ca79c8d2104d3791f7036267f9460a
#: ../../scala/futures.rst:90
msgid ""
"In this example we are joining two strings together within a ``Future``. "
"Instead of waiting for this to complete, we apply our function that "
"calculates the length of the string using the ``map`` method. Now we have a "
"second ``Future`` that will eventually contain an ``Int``. When our original "
"``Future`` completes, it will also apply our function and complete the "
"second ``Future`` with its result. When we finally get the result, it will "
"contain the number 10. Our original ``Future`` still contains the string "
"\"HelloWorld\" and is unaffected by the ``map``."
msgstr ""

# 9c4d6600bf5f4f54aaca16c50ca5fcd7
#: ../../scala/futures.rst:97
msgid ""
"The ``map`` method is fine if we are modifying a single ``Future``, but if 2 "
"or more ``Future``\\s are involved ``map`` will not allow you to combine "
"them together:"
msgstr ""

# c48cefa3e9474ee1855b1c1d6e08f359
#: ../../scala/futures.rst:103
msgid ""
"``f3`` is a ``Future[Future[Int]]`` instead of the desired ``Future[Int]``. "
"Instead, the ``flatMap`` method should be used:"
msgstr ""

# 379eaf43700f43bfb6e25304e934385d
#: ../../scala/futures.rst:108
msgid ""
"Composing futures using nested combinators it can sometimes become quite "
"complicated and hard read, in these cases using Scala's 'for comprehensions' "
"usually yields more readable code. See next section for examples."
msgstr ""

# 5f176fc30dcd4cbfb05634485ae2ef43
#: ../../scala/futures.rst:111
msgid "If you need to do conditional propagation, you can use ``filter``:"
msgstr ""

# de3805450f974a669a1f23bd195671e0
#: ../../scala/futures.rst:117
msgid "For Comprehensions"
msgstr ""

# 6db3f1c00c034c4783405e97dcc3ac0c
#: ../../scala/futures.rst:119
msgid ""
"Since ``Future`` has a ``map``, ``filter`` and ``flatMap`` method it can be "
"easily used in a 'for comprehension':"
msgstr ""

# ce6af2b58ccf4deb88f7c7ab13759d30
#: ../../scala/futures.rst:124
msgid ""
"Something to keep in mind when doing this is even though it looks like parts "
"of the above example can run in parallel, each step of the for comprehension "
"is run sequentially. This will happen on separate threads for each step but "
"there isn't much benefit over running the calculations all within a single "
"``Future``. The real benefit comes when the ``Future``\\s are created first, "
"and then combining them together."
msgstr ""

# 479fad84746c4ff4b657eab02a18fe56
#: ../../scala/futures.rst:130
msgid "Composing Futures"
msgstr ""

# 6a735e1af552411f9b0e8df4cee3901d
#: ../../scala/futures.rst:132
msgid ""
"The example for comprehension above is an example of composing ``Future``"
"\\s. A common use case for this is combining the replies of several ``Actor``"
"\\s into a single calculation without resorting to calling ``Await.result`` "
"or ``Await.ready`` to block for each result. First an example of using "
"``Await.result``:"
msgstr ""

# 21006e8137ea4154b24cf3ad3add9272
#: ../../scala/futures.rst:140
msgid ""
"Here we wait for the results from the first 2 ``Actor``\\s before sending "
"that result to the third ``Actor``. We called ``Await.result`` 3 times, "
"which caused our little program to block 3 times before getting our final "
"result. Now compare that to this example:"
msgstr ""

# 10f5025a950248c98a662e970ec2c6a9
#: ../../scala/futures.rst:147
msgid ""
"Here we have 2 actors processing a single message each. Once the 2 results "
"are available (note that we don't block to get these results!), they are "
"being added together and sent to a third ``Actor``, which replies with a "
"string, which we assign to 'result'."
msgstr ""

# c0ac20c4bb084cf4acc9d8bb86fa1139
#: ../../scala/futures.rst:151
msgid ""
"This is fine when dealing with a known amount of Actors, but can grow "
"unwieldy if we have more then a handful. The ``sequence`` and ``traverse`` "
"helper methods can make it easier to handle more complex use cases. Both of "
"these methods are ways of turning, for a subclass ``T`` of ``Traversable``, "
"``T[Future[A]]`` into a ``Future[T[A]]``. For example:"
msgstr ""

# 54490f75e2ed48faa477d2a03cd0a43b
#: ../../scala/futures.rst:159
msgid ""
"To better explain what happened in the example, ``Future.sequence`` is "
"taking the ``List[Future[Int]]`` and turning it into a ``Future[List[Int]]"
"``. We can then use ``map`` to work with the ``List[Int]`` directly, and we "
"find the sum of the ``List``."
msgstr ""

# f0db3088a75e4426a004c7680593d5d6
#: ../../scala/futures.rst:163
msgid ""
"The ``traverse`` method is similar to ``sequence``, but it takes a ``T[A]`` "
"and a function ``A => Future[B]`` to return a ``Future[T[B]]``, where ``T`` "
"is again a subclass of Traversable. For example, to use ``traverse`` to sum "
"the first 100 odd numbers:"
msgstr ""

# 68b49481411144d693ecdbdb4068854f
#: ../../scala/futures.rst:169
msgid "This is the same result as this example:"
msgstr ""

# 32e17b5353644d648262d56606b682a8
#: ../../scala/futures.rst:174
msgid ""
"But it may be faster to use ``traverse`` as it doesn't have to create an "
"intermediate ``List[Future[Int]]``."
msgstr ""

# 0c2229ae1eaf476ead07c609c876d9ce
#: ../../scala/futures.rst:176
msgid ""
"Then there's a method that's called ``fold`` that takes a start-value, a "
"sequence of ``Future``\\s and a function from the type of the start-value "
"and the type of the futures and returns something with the same type as the "
"start-value, and then applies the function to all elements in the sequence "
"of futures, asynchronously, the execution will start when the last of the "
"Futures is completed."
msgstr ""

# d1472b08dd584033821a517f50bf19ba
#: ../../scala/futures.rst:184
msgid "That's all it takes!"
msgstr ""

# 8d2cabd84efa42ecb00f8e3f47f48d1c
#: ../../scala/futures.rst:187
msgid ""
"If the sequence passed to ``fold`` is empty, it will return the start-value, "
"in the case above, that will be 0. In some cases you don't have a start-"
"value and you're able to use the value of the first completing Future in the "
"sequence as the start-value, you can use ``reduce``, it works like this:"
msgstr ""

# 672220d9d436421daff70041287c8a13
#: ../../scala/futures.rst:194
msgid ""
"Same as with ``fold``, the execution will be done asynchronously when the "
"last of the Future is completed, you can also parallelize it by chunking "
"your futures into sub-sequences and reduce them, and then reduce the reduced "
"results again."
msgstr ""

# 1feaa8395edf41319dcd21cc67883fce
#: ../../scala/futures.rst:198
msgid "Callbacks"
msgstr ""

# 31771638b36d427da922244514e15b8c
#: ../../scala/futures.rst:200
msgid ""
"Sometimes you just want to listen to a ``Future`` being completed, and react "
"to that not by creating a new Future, but by side-effecting. For this Akka "
"supports ``onComplete``, ``onSuccess`` and ``onFailure``, of which the "
"latter two are specializations of the first."
msgstr ""

# e373c9bebc564194ac4df78154777c56
#: ../../scala/futures.rst:213
msgid "Define Ordering"
msgstr ""

# 6266b68c11d24a6b96e027e232ae9064
#: ../../scala/futures.rst:215
msgid ""
"Since callbacks are executed in any order and potentially in parallel, it "
"can be tricky at the times when you need sequential ordering of operations. "
"But there's a solution and it's name is ``andThen``. It creates a new "
"``Future`` with the specified callback, a ``Future`` that will have the same "
"result as the ``Future`` it's called on, which allows for ordering like in "
"the following sample:"
msgstr ""

# 6ba7a1e31c50439c97d6dabd09ec46b9
#: ../../scala/futures.rst:225
msgid "Auxiliary Methods"
msgstr ""

# 7a3c0b75b4694814a0a4122b79f40b79
#: ../../scala/futures.rst:227
msgid ""
"``Future`` ``fallbackTo`` combines 2 Futures into a new ``Future``, and will "
"hold the successful value of the second ``Future`` if the first ``Future`` "
"fails."
msgstr ""

# 68f8ecf0be964bfd81241ef12fa6eb26
#: ../../scala/futures.rst:233
msgid ""
"You can also combine two Futures into a new ``Future`` that will hold a "
"tuple of the two Futures successful results, using the ``zip`` operation."
msgstr ""

# 9302d50148344eaf8727eeca1b33e3ee
#: ../../scala/futures.rst:240
msgid "Exceptions"
msgstr ""

# c35787c64b9a4e1d8c33937fcf7cae05
#: ../../scala/futures.rst:242
msgid ""
"Since the result of a ``Future`` is created concurrently to the rest of the "
"program, exceptions must be handled differently. It doesn't matter if an "
"``Actor`` or the dispatcher is completing the ``Future``, if an "
"``Exception`` is caught the ``Future`` will contain it instead of a valid "
"result. If a ``Future`` does contain an ``Exception``, calling ``Await."
"result`` will cause it to be thrown again so it can be handled properly."
msgstr ""

# 37854d64f97e4079b9697dc308efeb67
#: ../../scala/futures.rst:247
msgid ""
"It is also possible to handle an ``Exception`` by returning a different "
"result. This is done with the ``recover`` method. For example:"
msgstr ""

# 232e3fd2864f4c899b4ecfe03a9f8390
#: ../../scala/futures.rst:253
msgid ""
"In this example, if the actor replied with a ``akka.actor.Status.Failure`` "
"containing the ``ArithmeticException``, our ``Future`` would have a result "
"of 0. The ``recover`` method works very similarly to the standard try/catch "
"blocks, so multiple ``Exception``\\s can be handled in this manner, and if "
"an ``Exception`` is not handled this way it will behave as if we hadn't used "
"the ``recover`` method."
msgstr ""

# b81b68f8a6f045309419b735dd2cdd99
#: ../../scala/futures.rst:258
msgid ""
"You can also use the ``recoverWith`` method, which has the same relationship "
"to ``recover`` as ``flatMap`` has to ``map``, and is use like this:"
msgstr ""

# fa4ce024b46c4768b5a2221c6a2964b1
#: ../../scala/index.rst:4
msgid "Scala API"
msgstr ""

# 7a9daef8b0b6449ea39ca4f532e24bb1
#: ../../scala/io.rst:4
msgid "IO (Scala)"
msgstr ""

# 4514b1d15ff24eba8c88ddee0d0d88bb
#: ../../scala/io.rst:10
msgid ""
"This documentation is in progress and some sections may be incomplete. More "
"will be coming."
msgstr ""

# 11e36df568e7446cae0b4643831d357d
#: ../../scala/io.rst:13
msgid "Components"
msgstr ""

# aae66cd6c8414b709093b95a05d9769b
#: ../../scala/io.rst:16
msgid "ByteString"
msgstr ""

# 323822e929d54398a0dc08882363bfd0
#: ../../scala/io.rst:18
msgid ""
"A primary goal of Akka's IO module is to only communicate between actors "
"with immutable objects. When dealing with network IO on the jvm ``Array[Byte]"
"`` and ``ByteBuffer`` are commonly used to represent collections of ``Byte``"
"\\s, but they are mutable. Scala's collection library also lacks a suitably "
"efficient immutable collection for ``Byte``\\s. Being able to safely and "
"efficiently move ``Byte``\\s around is very important for this IO module, so "
"``ByteString`` was developed."
msgstr ""

# 6fca8d12fde04764866429026d4942da
#: ../../scala/io.rst:20
msgid ""
"``ByteString`` is a `Rope-like <http://en.wikipedia.org/wiki/Rope_"
"(computer_science)>`_ data structure that is immutable and efficient. When 2 "
"``ByteString``\\s are concatenated together they are both stored within the "
"resulting ``ByteString`` instead of copying both to a new ``Array``. "
"Operations such as ``drop`` and ``take`` return ``ByteString``\\s that still "
"reference the original ``Array``, but just change the offset and length that "
"is visible. Great care has also been taken to make sure that the internal "
"``Array`` cannot be modified. Whenever a potentially unsafe ``Array`` is "
"used to create a new ``ByteString`` a defensive copy is created."
msgstr ""

# 53b3fce4c7864391b60a7dd534284bf6
#: ../../scala/io.rst:22
msgid ""
"``ByteString`` inherits all methods from ``IndexedSeq``, and it also has "
"some new ones. For more information, look up the ``akka.util.ByteString`` "
"class and it's companion object in the `ScalaDoc <scaladoc>`_."
msgstr ""

# 1894cd62162b4ce2bdc4e33344711e28
#: ../../scala/io.rst:25
msgid "IO.Handle"
msgstr ""

# 8dec1e5f6a824179bd2c1257787fd42b
#: ../../scala/io.rst:27
msgid ""
"``IO.Handle`` is an immutable reference to a Java NIO ``Channel``. Passing "
"mutable ``Channel``\\s between ``Actor``\\s could lead to unsafe behavior, "
"so instead subclasses of the ``IO.Handle`` trait are used. Currently there "
"are 2 concrete subclasses: ``IO.SocketHandle`` (representing a "
"``SocketChannel``) and ``IO.ServerHandle`` (representing a "
"``ServerSocketChannel``)."
msgstr ""

# 87bf69c6b55840daa7892762d79f7fe3
#: ../../scala/io.rst:30
msgid "IOManager"
msgstr ""

# d17b644d04dc49da9b37d059929d8ad5
#: ../../scala/io.rst:32
msgid ""
"The ``IOManager`` takes care of the low level IO details. Each "
"``ActorSystem`` has it's own ``IOManager``, which can be accessed calling "
"``IOManager(system: ActorSystem)``. ``Actor``\\s communicate with the "
"``IOManager`` with specific messages. The messages sent from an ``Actor`` to "
"the ``IOManager`` are handled automatically when using certain methods and "
"the messages sent from an ``IOManager`` are handled within an ``Actor``\\'s "
"``receive`` method."
msgstr ""

# bfca5174b7244d4e9f66fd46d1df93d0
#: ../../scala/io.rst:34
msgid "Connecting to a remote host:"
msgstr ""

# 682480114fa143f493e7b37d8ac094e0
#: ../../scala/io.rst:45
msgid "Creating a server:"
msgstr ""

# aa872a27e18e4d42b0aac150c71005a4
#: ../../scala/io.rst:56
msgid "Receiving messages from the ``IOManager``:"
msgstr ""

# 10d244adbd904f60b379c397d06d1496
#: ../../scala/io.rst:88
msgid "IO.Iteratee"
msgstr ""

# f6c64cbd1eee4eccbfa54427893cb269
#: ../../scala/io.rst:90
msgid ""
"Included with Akka's IO module is a basic implementation of ``Iteratee``\\s. "
"``Iteratee``\\s are an effective way of handling a stream of data without "
"needing to wait for all the data to arrive. This is especially useful when "
"dealing with non blocking IO since we will usually receive data in chunks "
"which may not include enough information to process, or it may contain much "
"more data then we currently need."
msgstr ""

# 60e2bc60fc8743b2bb5dd92e9785ac28
#: ../../scala/io.rst:92
msgid ""
"This ``Iteratee`` implementation is much more basic then what is usually "
"found. There is only support for ``ByteString`` input, and enumerators "
"aren't used. The reason for this limited implementation is to reduce the "
"amount of explicit type signatures needed and to keep things simple. It is "
"important to note that Akka's ``Iteratee``\\s are completely optional, "
"incoming data can be handled in any way, including other ``Iteratee`` "
"libraries."
msgstr ""

# ddabd0cd2fb54dfda318539eb9dfa3a6
#: ../../scala/io.rst:94
msgid ""
"``Iteratee``\\s work by processing the data that it is given and returning "
"either the result (with any unused input) or a continuation if more input is "
"needed. They are monadic, so methods like ``flatMap`` can be used to pass "
"the result of an ``Iteratee`` to another."
msgstr ""

# b4e45cda4b944ef2bbd491880181fae2
#: ../../scala/io.rst:96
msgid ""
"The basic ``Iteratee``\\s included in the IO module can all be found in the "
"`ScalaDoc <scaladoc>`_ under ``akka.actor.IO``, and some of them are covered "
"in the example below."
msgstr ""

# 8b9ad980718f469a96c39b6b89ab0eeb
#: ../../scala/io.rst:102
msgid "Http Server"
msgstr ""

# 7a092d65720244ae97973f9ec483d68f
#: ../../scala/io.rst:104
msgid ""
"This example will create a simple high performance HTTP server. We begin "
"with our imports:"
msgstr ""

# 636e3a9c50ed427780e154c2e4e2b837
#: ../../scala/io.rst:109
msgid "Some commonly used constants:"
msgstr ""

# 7618a321aa9941869814d1ce06794796
#: ../../scala/io.rst:114
msgid "And case classes to hold the resulting request:"
msgstr ""

# 734b683e2ea34b2cba86f95d05b7f6f2
#: ../../scala/io.rst:119
msgid ""
"Now for our first ``Iteratee``. There are 3 main sections of a HTTP request: "
"the request line, the headers, and an optional body. The main request "
"``Iteratee`` handles each section separately:"
msgstr ""

# 863077c8375f4e878caa9d1e643cf157
#: ../../scala/io.rst:124
msgid ""
"In the above code ``readRequest`` takes the results of 3 different "
"``Iteratees`` (``readRequestLine``, ``readHeaders``, ``readBody``) and "
"combines them into a single ``Request`` object. ``readRequestLine`` actually "
"returns a tuple, so we extract it's individual components. ``readBody`` "
"depends on values contained within the header section, so we must pass those "
"to the method."
msgstr ""

# beb8686bd5474eb2872cfa5f6e35b5d4
#: ../../scala/io.rst:126
msgid ""
"The request line has 3 parts to it: the HTTP method, the requested URI, and "
"the HTTP version. The parts are separated by a single space, and the entire "
"request line ends with a ``CRLF``."
msgstr ""

# c1ee4f84dee348e785393f649800e63c
#: ../../scala/io.rst:131
msgid ""
"Reading the request method is simple as it is a single string ending in a "
"space. The simple ``Iteratee`` that performs this is ``IO.takeUntil"
"(delimiter: ByteString): Iteratee[ByteString]``. It keeps consuming input "
"until the specified delimiter is found. Reading the HTTP version is also a "
"simple string that ends with a ``CRLF``."
msgstr ""

# a9737c92170947db85605b95ec4d358e
#: ../../scala/io.rst:133
msgid ""
"The ``ascii`` method is a helper that takes a ``ByteString`` and parses it "
"as a ``US-ASCII`` ``String``."
msgstr ""

# 9dc6eb66d01040e2838f838740fec02f
#: ../../scala/io.rst:135
msgid ""
"Reading the request URI is a bit more complicated because we want to parse "
"the individual components of the URI instead of just returning a simple "
"string:"
msgstr ""

# 4809394d41e7423fa86a35dab881c18b
#: ../../scala/io.rst:140
msgid ""
"For this example we are only interested in handling absolute paths. To "
"detect if we the URI is an absolute path we use ``IO.peek(length: Int): "
"Iteratee[ByteString]``, which returns a ``ByteString`` of the request length "
"but doesn't actually consume the input. We peek at the next bit of input and "
"see if it matches our ``PATH`` constant (defined above as ``ByteString(\"/\")"
"``). If it doesn't match we throw an error, but for a more robust solution "
"we would want to handle other valid URIs."
msgstr ""

# 776cbb45fde14b88b71a8230faa5d813
#: ../../scala/io.rst:142
msgid "Next we handle the path itself:"
msgstr ""

# 1767b81a26604660a4d7485d9c5d9459
#: ../../scala/io.rst:147
msgid ""
"The ``step`` method is a recursive method that takes a ``List`` of the "
"accumulated path segments. It first checks if the remaining input starts "
"with the ``PATH`` constant, and if it does, it drops that input, and returns "
"the ``readUriPart`` ``Iteratee`` which has it's result added to the path "
"segment accumulator and the ``step`` method is run again."
msgstr ""

# 9d949ec26d8e42e7a790a733040080c3
#: ../../scala/io.rst:149
msgid ""
"If after reading in a path segment the next input does not start with a "
"path, we reverse the accumulated segments and return it (dropping the last "
"segment if it is blank)."
msgstr ""

# 11ac10a409004154b3ddd00f41999199
#: ../../scala/io.rst:151
msgid "Following the path we read in the query (if it exists):"
msgstr ""

# d3986da6ffaa4d22af1c29362fbb9ae1
#: ../../scala/io.rst:156
msgid ""
"It is much simpler then reading the path since we aren't doing any parsing "
"of the query since there is no standard format of the query string."
msgstr ""

# ef176a95724543d09adad66920ed0cc5
#: ../../scala/io.rst:158
msgid ""
"Both the path and query used the ``readUriPart`` ``Iteratee``, which is next:"
msgstr ""

# 5bef9a21b7574e83ae497d658df21001
#: ../../scala/io.rst:163
msgid ""
"Here we have several ``Set``\\s that contain valid characters pulled from "
"the URI spec. The ``readUriPart`` method takes a ``Set`` of valid characters "
"(already mapped to ``Byte``\\s) and will continue to match characters until "
"it reaches on that is not part of the ``Set``. If it is a percent encoded "
"character then that is handled as a valid character and processing "
"continues, or else we are done collecting this part of the URI."
msgstr ""

# 400a4b8eb8d446438cd4e4433fb837a8
#: ../../scala/io.rst:165
msgid "Headers are next:"
msgstr ""

# afe3aa7b97294d87b1da322ac4c8fb60
#: ../../scala/io.rst:170
msgid "And if applicable, we read in the message body:"
msgstr ""

# aa7e0b236de04d1bb8e532470d1b6bfb
#: ../../scala/io.rst:175
msgid "Finally we get to the actual ``Actor``:"
msgstr ""

# 6b51f46590984e7d8e6c8c44ff5ff2b6
#: ../../scala/io.rst:180
msgid "And it's companion object:"
msgstr ""

# cf0330d8372a43c48c12f1850a8c72a8
#: ../../scala/io.rst:185
msgid "A ``main`` method to start everything up:"
msgstr ""

# 715f69014a7746d1ae3ba8552d5d0a65
#: ../../scala/logging.rst:5
msgid "Logging (Scala)"
msgstr ""

# cbbbfd02f9e64d5e943cf688019b7a2f
#: ../../scala/logging.rst:9
msgid "How to Log"
msgstr ""

# fbdb006fd0684f898d025048ee6944e1
#: ../../scala/logging.rst:11
msgid ""
"Create a ``LoggingAdapter`` and use the ``error``, ``warning``, ``info``, or "
"``debug`` methods, as illustrated in this example:"
msgstr ""

# 6a0903ee81ac41deb1eab1d1952bbf31
#: ../../scala/logging.rst:17
msgid ""
"For convenience you can mixin the ``log`` member into actors, instead of "
"defining it as above."
msgstr ""

# dd2b94fbc5ef4f9a9cdb465227d7ccd6
#: ../../scala/logging.rst:25
msgid ""
"The second parameter to the ``Logging`` is the source of this logging "
"channel. The source object is translated to a String according to the "
"following rules:"
msgstr ""

# 15b90de8801e4564b160a6426e2c4091
#: ../../scala/logging.rst:28
msgid "if it is an Actor or ActorRef, its path is used"
msgstr ""

# 9a309796149642b1bc4cd9ace97524cd
#: ../../scala/logging.rst:29
msgid "in case of a String it is used as is"
msgstr ""

# acfad3a0a5b44a0f8148d9d4eb99c0c6
#: ../../scala/logging.rst:30
msgid "in case of a class an approximation of its simpleName"
msgstr ""

# a0ba1767ada04cc3b97953dd420b41e7
#: ../../scala/logging.rst:31
msgid ""
"and in all other cases a compile error occurs unless and implicit :class:"
"`LogSource[T]` is in scope for the type in question."
msgstr ""

# 7c397029b5414fcfb852f6ffa26fca4b
#: ../../scala/logging.rst:34
msgid ""
"The log message may contain argument placeholders ``{}``, which will be "
"substituted if the log level is enabled. Giving more arguments as there are "
"placeholders results in a warning being appended to the log statement (i.e. "
"on the same line with the same severity). You may pass a Java array as the "
"only substitution argument to have its elements be treated individually:"
msgstr ""

# 1b44aad217e340a1a02c7004e93f9789
#: ../../scala/logging.rst:42
msgid ""
"The Java :class:`Class` of the log source is also included in the generated :"
"class:`LogEvent`. In case of a simple string this is replaced with a "
"“marker” class :class:`akka.event.DummyClassForStringSources` in order to "
"allow special treatment of this case, e.g. in the SLF4J event listener which "
"will then use the string instead of the class’ name for looking up the "
"logger instance to use."
msgstr ""

# 50b0db79398c4c5895b344d235e0e2ad
#: ../../scala/logging.rst:50
msgid "Auxiliary logging options"
msgstr ""

# 5f670b17b7824c83a843b562065c7ad9
#: ../../scala/logging.rst:52
msgid ""
"Akka has a couple of configuration options for very low level debugging, "
"that makes most sense in for developers and not for operations."
msgstr ""

# 8776f60c14114304aed0f4a36b10f0e6
#: ../../scala/logging.rst:55
msgid ""
"You almost definitely need to have logging set to DEBUG to use any of the "
"options below:"
msgstr ""

# 23b972d5b292467290ea260835469a77
#: ../../scala/logging.rst:63
msgid ""
"This config option is very good if you want to know what config settings are "
"loaded by Akka:"
msgstr ""

# aebe91ec80104855b8233c358ef28194
#: ../../scala/logging.rst:73
msgid ""
"If you want very detailed logging of all user-level messages that are "
"processed by Actors that use akka.event.LoggingReceive:"
msgstr ""

# faf9adae7f064315952aef04e7506323
#: ../../scala/logging.rst:86
msgid ""
"If you want very detailed logging of all automatically received messages "
"that are processed by Actors:"
msgstr ""

# 00b8e3fa85f14744bdbd8cbf72e4c4d1
#: ../../scala/logging.rst:98
msgid ""
"If you want very detailed logging of all lifecycle changes of Actors "
"(restarts, deaths etc):"
msgstr ""

# 7788769164524b63a6db37852cf65fb7
#: ../../scala/logging.rst:109
msgid ""
"If you want very detailed logging of all events, transitions and timers of "
"FSM Actors that extend LoggingFSM:"
msgstr ""

# 426a9cac8a9141c99b8c614732a2b186
#: ../../scala/logging.rst:120
msgid ""
"If you want to monitor subscriptions (subscribe/unsubscribe) on the "
"ActorSystem.eventStream:"
msgstr ""

# b12b3b488d5b45329dbd3c406669c324
#: ../../scala/logging.rst:132
msgid "Auxiliary remote logging options"
msgstr ""

# bc44091f5720458a925ce2d9f88c164b
#: ../../scala/logging.rst:134
msgid ""
"If you want to see all messages that are sent through remoting at DEBUG log "
"level: (This is logged as they are sent by the transport layer, not by the "
"Actor)"
msgstr ""

# 76cb45dfad22414fb50a9310b5c5a0fd
#: ../../scala/logging.rst:146
msgid ""
"If you want to see all messages that are received through remoting at DEBUG "
"log level: (This is logged as they are received by the transport layer, not "
"by any Actor)"
msgstr ""

# 25170c840a78438c8db93302cc46d7d5
#: ../../scala/logging.rst:158
msgid "Also see the logging options for TestKit: :ref:`actor.logging`."
msgstr ""

# 8148f90c2f7f4e138d5adccdf1f05160
#: ../../scala/logging.rst:161
msgid "Translating Log Source to String and Class"
msgstr ""

# 9cf2774335e84dc08c5f3ff51edf080c
#: ../../scala/logging.rst:163
msgid ""
"The rules for translating the source object to the source string and class "
"which are inserted into the :class:`LogEvent` during runtime are implemented "
"using implicit parameters and thus fully customizable: simply create your "
"own instance of :class:`LogSource[T]` and have it in scope when creating the "
"logger."
msgstr ""

# 1fc4f3d5fb82473fa5cb0a929b2a5e03
#: ../../scala/logging.rst:171
msgid ""
"This example creates a log source which mimics traditional usage of Java "
"loggers, which are based upon the originating object’s class name as log "
"category. The override of :meth:`getClazz` is only included for "
"demonstration purposes as it contains exactly the default behavior."
msgstr ""

# 7866941972124e559960da021c6af623
#: ../../scala/logging.rst:178
msgid ""
"You may also create the string representation up front and pass that in as "
"the log source, but be aware that then the :class:`Class[_]` which will be "
"put in the :class:`LogEvent` is :class:`akka.event."
"DummyClassForStringSources`."
msgstr ""

# c02de2af6ec047c6887b87ada6c08fa6
#: ../../scala/logging.rst:183
msgid ""
"The SLF4J event listener treats this case specially (using the actual string "
"to look up the logger instance to use instead of the class’ name), and you "
"might want to do this also in case you implement your own logging adapter."
msgstr ""

# 06b52507ac734816b697f2be1d38f302
#: ../../scala/logging.rst:188
msgid "Event Handler"
msgstr ""

# 466829dcce3447668283de9d3d88fb9e
#: ../../scala/logging.rst:190
msgid ""
"Logging is performed asynchronously through an event bus. You can configure "
"which event handlers that should subscribe to the logging events. That is "
"done using the ``event-handlers`` element in the :ref:`configuration`.  Here "
"you can also define the log level."
msgstr ""

# 33bccc41ee6a4072a8378a24600d3a64
#: ../../scala/logging.rst:204
msgid ""
"The default one logs to STDOUT and is registered by default. It is not "
"intended to be used for production. There is also an :ref:`slf4j-scala` "
"event handler available in the 'akka-slf4j' module."
msgstr ""

# 623239c319df4189bdc5c3a8bb5dd9dc
#: ../../scala/logging.rst:208
msgid "Example of creating a listener:"
msgstr ""

# 6f5b0f5086f940f19e346712343ee34b
#: ../../scala/logging.rst:216
msgid "SLF4J"
msgstr ""

# ac8b62f9d693443baf48a751c7b90ff2
#: ../../scala/logging.rst:218
msgid ""
"Akka provides an event handler for `SL4FJ <http://www.slf4j.org/>`_. This "
"module is available in the 'akka-slf4j.jar'. It has one single dependency; "
"the slf4j-api jar. In runtime you also need a SLF4J backend, we recommend "
"`Logback <http://logback.qos.ch/>`_:"
msgstr ""

# 87a43146926d4d06aef46163795bd604
#: ../../scala/logging.rst:226
msgid ""
"You need to enable the Slf4jEventHandler in the 'event-handlers' element in "
"the :ref:`configuration`. Here you can also define the log level of the "
"event bus. More fine grained log levels can be defined in the configuration "
"of the SLF4J backend (e.g. logback.xml)."
msgstr ""

# 5b7262fb5c564748807987ba89eefb13
#: ../../scala/logging.rst:238
msgid ""
"The SLF4J logger selected for each log event is chosen based on the :class:"
"`Class[_]` of the log source specified when creating the :class:"
"`LoggingAdapter`, unless that was given directly as a string in which case "
"that string is used (i.e. ``LoggerFactory.getLogger(c: Class[_])`` is used "
"in the first case and ``LoggerFactory.getLogger(s: String)`` in the second)."
msgstr ""

# 18a615f96b6d4d098cd890e3c44e0cd7
#: ../../scala/logging.rst:246
msgid ""
"Beware that the the actor system’s name is appended to a :class:`String` log "
"source if the LoggingAdapter was created giving an :class:`ActorSystem` to "
"the factory. If this is not intended, give a :class:`LoggingBus` instead as "
"shown below:"
msgstr ""

# ddc647e937be4f0aae6cfd4ff7d14cbe
#: ../../scala/logging.rst:256
msgid "Logging Thread and Akka Source in MDC"
msgstr ""

# efb37a8d9d124e049e149050d8a6a7f9
#: ../../scala/logging.rst:258
msgid ""
"Since the logging is done asynchronously the thread in which the logging was "
"performed is captured in Mapped Diagnostic Context (MDC) with attribute name "
"``sourceThread``. With Logback the thread name is available with ``%X"
"{sourceThread}`` specifier within the pattern layout configuration::"
msgstr ""

# ecd1d5226ce7428b86985e2c7adac8b5
#: ../../scala/logging.rst:270
msgid ""
"It will probably be a good idea to use the ``sourceThread`` MDC value also "
"in non-Akka parts of the application in order to have this property "
"consistently available in the logs."
msgstr ""

# e07a19951edc4dd29436afaca806c19d
#: ../../scala/logging.rst:274
msgid ""
"Another helpful facility is that Akka captures the actor’s address when "
"instantiating a logger within it, meaning that the full instance "
"identification is available for associating log messages e.g. with members "
"of a router. This information is available in the MDC with attribute name "
"``akkaSource``::"
msgstr ""

# 6561b550bccd4101bb6dc751b40697c5
#: ../../scala/logging.rst:285
msgid ""
"For more details on what this attribute contains—also for non-actors—please "
"see `How to Log`_."
msgstr ""

# 25798dcf4f9f4eafb886f20196cdd9f8
#: ../../scala/remoting.rst:5
msgid "Remoting (Scala)"
msgstr ""

# 7ac540a832b147bf88cae5464ecf77b6
#: ../../scala/remoting.rst:8
msgid ""
"For an introduction of remoting capabilities of Akka please see :ref:"
"`remoting`."
msgstr ""

# 8fbf3d38815c4d13b9c4648a2b0bc61e
#: ../../scala/remoting.rst:11
msgid "Preparing your ActorSystem for Remoting"
msgstr ""

# bb7a34d65b584e76b50da0a19fb889bd
#: ../../scala/remoting.rst:13
msgid ""
"The Akka remoting is a separate jar file. Make sure that you have the "
"following dependency in your project::"
msgstr ""

# c1cbda11ce304e0d80f4e0767804e8ed
#: ../../scala/remoting.rst:17
msgid ""
"To enable remote capabilities in your Akka project you should, at a minimum, "
"add the following changes to your ``application.conf`` file::"
msgstr ""

# bd278aed3ceb4013aa96871227b4267d
#: ../../scala/remoting.rst:33
msgid ""
"As you can see in the example above there are four things you need to add to "
"get started:"
msgstr ""

# 7da6ce05d3514cbcbe05e4c4898b6c19
#: ../../scala/remoting.rst:35
msgid ""
"Change provider from ``akka.actor.LocalActorRefProvider`` to ``akka.remote."
"RemoteActorRefProvider``"
msgstr ""

# 2816ec9975094bbda392adf62d8ad6bc
#: ../../scala/remoting.rst:36
msgid ""
"Add host name - the machine you want to run the actor system on; this host "
"name is exactly what is passed to remote systems in order to identify this "
"system and consequently used for connecting back to this system if need be, "
"hence set it to a reachable IP address or resolvable name in case you want "
"to communicate across the network."
msgstr ""

# 7a5d90796711411392b85f2af4e31e56
#: ../../scala/remoting.rst:41
msgid ""
"Add port number - the port the actor system should listen on, set to 0 to "
"have it chosen automatically"
msgstr ""

# 28df8d2ce7b245c0bf08ee20ec3b62e4
#: ../../scala/remoting.rst:43
msgid ""
"The example above only illustrates the bare minimum of properties you have "
"to add to enable remoting. There are lots of more properties that are "
"related to remoting in Akka. We refer to the following reference file for "
"more information:"
msgstr ""

# 3f0e842708bc42e5be3e67ff2e4b5120
#: ../../scala/remoting.rst:51
msgid "Types of Remote Interaction"
msgstr ""

# db0ba82e5f6a47d4a1172bce0d76c8f2
#: ../../scala/remoting.rst:53
msgid "Akka has two ways of using remoting:"
msgstr ""

# f5801dda986e4a5192eb31cc8b99ec63
#: ../../scala/remoting.rst:55
msgid ""
"Lookup    : used to look up an actor on a remote node with ``actorFor(path)``"
msgstr ""

# 2c0c86c0dc634ce2b9d846adb8e3a702
#: ../../scala/remoting.rst:56
msgid ""
"Creation  : used to create an actor on a remote node with ``actorOf(Props"
"(...), actorName)``"
msgstr ""

# 73e20ead2fec4ebfa54a906d2270b6f3
#: ../../scala/remoting.rst:58
msgid "In the next sections the two alternatives are described in detail."
msgstr ""

# 8473c8ec6b7448cea16aa210d9c84147
#: ../../scala/remoting.rst:61
msgid "Looking up Remote Actors"
msgstr ""

# 5a12589afa8b442fb24530506a5c8a10
#: ../../scala/remoting.rst:63
msgid ""
"``actorFor(path)`` will obtain an ``ActorRef`` to an Actor on a remote node, "
"e.g.::"
msgstr ""

# b739678cf79248258a482c63daf299fd
#: ../../scala/remoting.rst:67
msgid ""
"As you can see from the example above the following pattern is used to find "
"an ``ActorRef`` on a remote node::"
msgstr ""

# 66b2f7e4f0a2449fbba743337730fcf9
#: ../../scala/remoting.rst:71
msgid ""
"Once you obtained a reference to the actor you can interact with it they "
"same way you would with a local actor, e.g.::"
msgstr ""

# 99625bdba0ad482c9c597bf4c551b207
#: ../../scala/remoting.rst:75
msgid ""
"For more details on how actor addresses and paths are formed and used, "
"please refer to :ref:`addressing`."
msgstr ""

# c22a18ac238446ba8cb38c23ec2d3932
#: ../../scala/remoting.rst:78
msgid "Creating Actors Remotely"
msgstr ""

# ba200c0b799045838164d768d17cfbfc
#: ../../scala/remoting.rst:80
msgid ""
"If you want to use the creation functionality in Akka remoting you have to "
"further amend the ``application.conf`` file in the following way (only "
"showing deployment section)::"
msgstr ""

# 69859ff0aefd41539ce7f47587e1fcdf
#: ../../scala/remoting.rst:93
msgid ""
"The configuration above instructs Akka to react when an actor with path ``/"
"sampleActor`` is created, i.e. using ``system.actorOf(Props(...)`, "
"sampleActor)``. This specific actor will not be directly instantiated, but "
"instead the remote daemon of the remote system will be asked to create the "
"actor, which in this sample corresponds to "
"``sampleActorSystem@127.0.0.1:2553``."
msgstr ""

# 3c61cbb31d374ec5954c6b17023ea705
#: ../../scala/remoting.rst:98
msgid ""
"Once you have configured the properties above you would do the following in "
"code::"
msgstr ""

# 060ffd962ade4187a5f6478dc5405010
#: ../../scala/remoting.rst:105
msgid ""
"``SampleActor`` has to be available to the runtimes using it, i.e. the "
"classloader of the actor systems has to have a JAR containing the class."
msgstr ""

# 80e36ab3042840a28a26ba2c3ee90f50
#: ../../scala/remoting.rst:109
msgid "Programmatic Remote Deployment"
msgstr ""

# 6f089dbd19a64c08b62787d99efabaf2
#: ../../scala/remoting.rst:111
msgid ""
"To allow dynamically deployed systems, it is also possible to include "
"deployment configuration in the :class:`Props` which are used to create an "
"actor: this information is the equivalent of a deployment section from the "
"configuration file, and if both are given, the external configuration takes "
"precedence."
msgstr ""

# b624b0289e8c4480abf51eb24f3ffead
#: ../../scala/remoting.rst:117
msgid "With these imports:"
msgstr ""

# 73982722e5b844729a2064e466045b11
#: ../../scala/remoting.rst:121
msgid "and a remote address like this:"
msgstr ""

# 8b6784186bb8460695e0f88fd6a1f83a
#: ../../scala/remoting.rst:125
msgid ""
"you can advise the system to create a child on that remote node like so:"
msgstr ""

# ed4f95b6c8724e5a8375e4ef23043e74
#: ../../scala/remoting.rst:130
msgid "Serialization"
msgstr ""

# 1ea26cc9d686461f8fd43be2ed44d676
#: ../../scala/remoting.rst:132
msgid ""
"When using remoting for actors you must ensure that the ``props`` and "
"``messages`` used for those actors are serializable. Failing to do so will "
"cause the system to behave in an unintended way."
msgstr ""

# 78de08ffa0ee4c96b58b69c3c78f1d3c
#: ../../scala/remoting.rst:135
msgid "For more information please see :ref:`serialization-scala`"
msgstr ""

# 7539a8ab797242648e91ce17992f63c0
#: ../../scala/remoting.rst:138
msgid "Routers with Remote Destinations"
msgstr ""

# e762c949a4c1499dad63482947b84e78
#: ../../scala/remoting.rst:140
msgid ""
"It is absolutely feasible to combine remoting with :ref:`routing-scala`. "
"This is also done via configuration::"
msgstr ""

# e22a721dac0d45759850a28a4d90315e
#: ../../scala/remoting.rst:157
msgid ""
"This configuration setting will clone the actor “aggregation” 10 times and "
"deploy it evenly distributed across the two given target nodes."
msgstr ""

# e8802e5f031c4a4e890124102dcf133b
#: ../../scala/remoting.rst:161
msgid "Description of the Remoting Sample"
msgstr ""

# fd64c0ceb8224ea288a06b17ffff719b
#: ../../scala/remoting.rst:163
msgid ""
"There is a more extensive remote example that comes with the Akka "
"distribution. Please have a look here for more information: `Remote Sample "
"<https://github.com/akka/akka/tree/master/akka-samples/akka-sample-remote>`_ "
"This sample demonstrates both, remote deployment and look-up of remote "
"actors. First, let us have a look at the common setup for both scenarios "
"(this is ``common.conf``):"
msgstr ""

# 83cde2d237494941b5f231f4fd3290ef
#: ../../scala/remoting.rst:172
msgid ""
"This enables the remoting by installing the :class:`RemoteActorRefProvider` "
"and chooses the default remote transport. All other options will be set "
"specifically for each show case."
msgstr ""

# d50842246102424b9be1b94b29758bd4
#: ../../scala/remoting.rst:178
msgid ""
"Be sure to replace the default IP 127.0.0.1 with the real address the system "
"is reachable by if you deploy onto multiple machines!"
msgstr ""

# 32ba4460d2504ae39895244f62238f01
#: ../../scala/remoting.rst:184
msgid "Remote Lookup"
msgstr ""

# 131e92d6f86149589b7e9006857ed729
#: ../../scala/remoting.rst:186
msgid ""
"In order to look up a remote actor, that one must be created first. For this "
"purpose, we configure an actor system to listen on port 2552 (this is a "
"snippet from ``application.conf``):"
msgstr ""

# 5bafa99ed86049008530fb4110228a03
#: ../../scala/remoting.rst:193
msgid ""
"Then the actor must be created. For all code which follows, assume these "
"imports:"
msgstr ""

# a28d66cb1ef54e42afe0844affb20ee5
#: ../../scala/remoting.rst:198
msgid "The actor doing the work will be this one:"
msgstr ""

# dbcb29c5c0d24a1cbca8b5c5c4c199dc
#: ../../scala/remoting.rst:203
msgid "and we start it within an actor system using the above configuration"
msgstr ""

# a2f9e1f8a6db4c9199b8b8e3a759a0c7
#: ../../scala/remoting.rst:208
msgid ""
"With the service actor up and running, we may look it up from another actor "
"system, which will be configured to use port 2553 (this is a snippet from "
"``application.conf``)."
msgstr ""

# ca1ce9db8162470cbba5afa6ffcd1010
#: ../../scala/remoting.rst:215
msgid ""
"The actor which will query the calculator is a quite simple one for "
"demonstration purposes"
msgstr ""

# 6925058cbf194065b76d2079543d3369
#: ../../scala/remoting.rst:220
msgid ""
"and it is created from an actor system using the aforementioned client’s "
"config."
msgstr ""

# c851d0d5e11942679603e0f76a5ca7a5
#: ../../scala/remoting.rst:225
msgid ""
"Requests which come in via ``doSomething`` will be sent to the client actor "
"along with the reference which was looked up earlier. Observe how the actor "
"system name using in ``actorFor`` matches the remote system’s name, as do IP "
"and port number. Top-level actors are always created below the ``\"/user\"`` "
"guardian, which supervises them."
msgstr ""

# 0afda262f97645b3b1076c0134a6d01f
#: ../../scala/remoting.rst:232
msgid "Remote Deployment"
msgstr ""

# c16974362c18421a9c5dca7062edfa5e
#: ../../scala/remoting.rst:234
msgid ""
"Creating remote actors instead of looking them up is not visible in the "
"source code, only in the configuration file. This section is used in this "
"scenario (this is a snippet from ``application.conf``):"
msgstr ""

# e3e255f3681a40e0ac1f72376a5df527
#: ../../scala/remoting.rst:241
msgid "For all code which follows, assume these imports:"
msgstr ""

# 34f0e440277b4980b4454d8c79ddbcf2
#: ../../scala/remoting.rst:246
msgid "The client actor looks like in the previous example"
msgstr ""

# 2c5be05a4c4a40109c70ac6e8b8c7d25
#: ../../scala/remoting.rst:251
msgid "but the setup uses only ``actorOf``:"
msgstr ""

# da90e631d1284fbd8fce9bee760aa360
#: ../../scala/remoting.rst:256
msgid ""
"Observe how the name of the server actor matches the deployment given in the "
"configuration file, which will transparently delegate the actor creation to "
"the remote node."
msgstr ""

# a14e081d9d92458fa025231d97ad88c5
#: ../../scala/remoting.rst:261
msgid "Remote Events"
msgstr ""

# 5afe5d6441e241f1814313c22bb7daa2
#: ../../scala/remoting.rst:263
msgid ""
"It is possible to listen to events that occur in Akka Remote, and to "
"subscribe/unsubscribe to there events, you simply register as listener to "
"the below described types in on the ``ActorSystem.eventStream``."
msgstr ""

# da0b7ebe9c544ba0832842eb1b3d8685
#: ../../scala/remoting.rst:267
msgid ""
"To subscribe to any outbound-related events, subscribe to "
"``RemoteClientLifeCycleEvent`` To subscribe to any inbound-related events, "
"subscribe to ``RemoteServerLifeCycleEvent`` To subscribe to any remote "
"events, subscribe to ``RemoteLifeCycleEvent``"
msgstr ""

# 4d52d52148644a218e16baeccc669cc5
#: ../../scala/remoting.rst:271
msgid ""
"To intercept when an outbound connection is disconnected, you listen to "
"``RemoteClientDisconnected`` which holds the transport used "
"(RemoteTransport) and the outbound address that was disconnected (Address)."
msgstr ""

# 1b5e70e396ee445f81308910cc16ccc4
#: ../../scala/remoting.rst:274
msgid ""
"To intercept when an outbound connection is connected, you listen to "
"``RemoteClientConnected`` which holds the transport used (RemoteTransport) "
"and the outbound address that was connected to (Address)."
msgstr ""

# 08bf513d597642d0997139f7392fb001
#: ../../scala/remoting.rst:277
msgid ""
"To intercept when an outbound client is started you listen to "
"``RemoteClientStarted`` which holds the transport used (RemoteTransport) and "
"the outbound address that it is connected to (Address)."
msgstr ""

# 872c2f60d9c343dfafc1ec7c8c1d97bb
#: ../../scala/remoting.rst:280
msgid ""
"To intercept when an outbound client is shut down you listen to "
"``RemoteClientShutdown`` which holds the transport used (RemoteTransport) "
"and the outbound address that it was connected to (Address)."
msgstr ""

# a4166551a28842d08b9ed7d9a6007ea3
#: ../../scala/remoting.rst:283
msgid ""
"To intercept when an outbound message cannot be sent, you listen to "
"``RemoteClientWriteFailed`` which holds the payload that was not written "
"(AnyRef), the cause of the failed send (Throwable), the transport used "
"(RemoteTransport) and the outbound address that was the destination "
"(Address)."
msgstr ""

# 905c7a45e23741b68ef1204bfdded5af
#: ../../scala/remoting.rst:287
msgid ""
"For general outbound-related errors, that do not classify as any of the "
"others, you can listen to ``RemoteClientError``, which holds the cause "
"(Throwable), the transport used (RemoteTransport) and the outbound address "
"(Address)."
msgstr ""

# 0ba5f4756a86480195bd77103569c6d5
#: ../../scala/remoting.rst:290
msgid ""
"To intercept when an inbound server is started (typically only once) you "
"listen to ``RemoteServerStarted`` which holds the transport that it will use "
"(RemoteTransport)."
msgstr ""

# bc77212dea0448d4ba26e5d2a2d5b759
#: ../../scala/remoting.rst:293
msgid ""
"To intercept when an inbound server is shut down (typically only once) you "
"listen to ``RemoteServerShutdown`` which holds the transport that it used "
"(RemoteTransport)."
msgstr ""

# cc42e6750d7e44f2a433ed278e610d68
#: ../../scala/remoting.rst:296
msgid ""
"To intercept when an inbound connection has been established you listen to "
"``RemoteServerClientConnected`` which holds the transport used "
"(RemoteTransport) and optionally the address that connected (Option"
"[Address])."
msgstr ""

# 26f6d6fe962f4759be1ef1c83a7cdd37
#: ../../scala/remoting.rst:299
msgid ""
"To intercept when an inbound connection has been disconnected you listen to "
"``RemoteServerClientDisconnected`` which holds the transport used "
"(RemoteTransport) and optionally the address that disconnected (Option"
"[Address])."
msgstr ""

# 66c71d1d3f844dc48ebdb53b36751230
#: ../../scala/remoting.rst:302
msgid ""
"To intercept when an inbound remote client has been closed you listen to "
"``RemoteServerClientClosed`` which holds the transport used "
"(RemoteTransport) and optionally the address of the remote client that was "
"closed (Option[Address])."
msgstr ""

# 84a82ea9c7494af0b98335200a76bf9a
#: ../../scala/routing.rst:5
msgid "Routing (Scala)"
msgstr ""

# b4c0023e2aeb4310a61045228684238d
#: ../../scala/routing.rst:7
msgid ""
"A Router is an actor that routes incoming messages to outbound actors. The "
"router routes the messages sent to it to its underlying actors called "
"'routees'."
msgstr ""

# 1e3f20ff59424783a4ee46a340678367
#: ../../scala/routing.rst:10
msgid ""
"Akka comes with some defined routers out of the box, but as you will see in "
"this chapter it is really easy to create your own. The routers shipped with "
"Akka are:"
msgstr ""

# 2ed2b94469fd418abd435e7432ec157e
#: ../../scala/routing.rst:13
msgid "``akka.routing.RoundRobinRouter``"
msgstr ""

# 08ef901800904542996aecd9c1c10718
#: ../../scala/routing.rst:14
msgid "``akka.routing.RandomRouter``"
msgstr ""

# b48154bcfa7940dfb08580137007d0bc
#: ../../scala/routing.rst:15
msgid "``akka.routing.SmallestMailboxRouter``"
msgstr ""

# 0d353f1de2294597b05b9d77d8f64b04
#: ../../scala/routing.rst:16
msgid "``akka.routing.BroadcastRouter``"
msgstr ""

# fcde68ea9021484d907366164f009f3b
#: ../../scala/routing.rst:17
msgid "``akka.routing.ScatterGatherFirstCompletedRouter``"
msgstr ""

# 8be6c8aee28944fb80d111622d9e1e4e
#: ../../scala/routing.rst:20
msgid "Routers In Action"
msgstr ""

# 28f1e45e98194cc8b2c1fe6565a0b1cb
#: ../../scala/routing.rst:22
msgid ""
"This is an example of how to create a router that is defined in "
"configuration:"
msgstr ""

# 4bbe76190c5f4ddfadd9aeb6dc06bac0
#: ../../scala/routing.rst:28
msgid ""
"This is an example of how to programmatically create a router and set the "
"number of routees it should create:"
msgstr ""

# 2bec00d29cd24746963d0fa64dc15d66
#: ../../scala/routing.rst:32
msgid "You can also give the router already created routees as in:"
msgstr ""

# 5028e9ac80de4712b16810b2b69e9c2b
#: ../../scala/routing.rst:36
msgid ""
"When you create a router programmatically you define the number of routees "
"*or* you pass already created routees to it. If you send both parameters to "
"the router *only* the latter will be used, i.e. ``nrOfInstances`` is "
"disregarded."
msgstr ""

# 50ff8bb221d94969a060cbb264b23ceb
#: ../../scala/routing.rst:39
msgid ""
"*It is also worth pointing out that if you define the ``router`` in the "
"configuration file then this value will be used instead of any "
"programmatically sent parameters. The decision whether to create a router at "
"all, on the other hand, must be taken within the code, i.e. you cannot make "
"something a router by external configuration alone (see below for details).*"
msgstr ""

# 691a0fdb79b64e47a5a069a87cd229d3
#: ../../scala/routing.rst:45
msgid ""
"Once you have the router actor it is just to send messages to it as you "
"would to any actor:"
msgstr ""

# e83f476279a64339a7bf7e51f02f999b
#: ../../scala/routing.rst:51
msgid ""
"The router will apply its behavior to the message it receives and forward it "
"to the routees."
msgstr ""

# 57bbdd3031a04ffbbb0026065296cf7b
#: ../../scala/routing.rst:54
msgid "Remotely Deploying Routees"
msgstr ""

# 270e6d4018de4456b5be8cc0c080ca02
#: ../../scala/routing.rst:56
msgid ""
"In addition to being able to supply looked-up remote actors as routees, you "
"can make the router deploy its created children on a set of remote hosts; "
"this will be done in round-robin fashion. In order to do that, wrap the "
"router configuration in a :class:`RemoteRouterConfig`, attaching the remote "
"addresses of the nodes to deploy to. Naturally, this requires your to "
"include the ``akka-remote`` module on your classpath:"
msgstr ""

# d806b38a847e4ac5923e9bb14af16cef
#: ../../scala/routing.rst:66
msgid "How Routing is Designed within Akka"
msgstr ""

# b29a3ca2bcbb4a078366232abacf98d6
#: ../../scala/routing.rst:68
msgid ""
"Routers behave like single actors, but they should also not hinder "
"scalability. This apparent contradiction is solved by making routers be "
"represented by a special :class:`RoutedActorRef`, which dispatches incoming "
"messages destined for the routees without actually invoking the router "
"actor’s behavior (and thus avoiding its mailbox; the single router actor’s "
"task is to manage all aspects related to the lifecycle of the routees). This "
"means that the code which decides which route to take is invoked "
"concurrently from all possible senders and hence must be thread-safe, it "
"cannot live the simple and happy life of code within an actor."
msgstr ""

# 4d2dd7be1c5d43088c17fc014c61a070
#: ../../scala/routing.rst:78
msgid ""
"There is one part in the above paragraph which warrants some more background "
"explanation: Why does a router need a “head” which is actual parent to all "
"the routees? The initial design tried to side-step this issue, but location "
"transparency as well as mandatory parental supervision required a redesign. "
"Each of the actors which the router spawns must have its unique identity, "
"which translates into a unique actor path. Since the router has only one "
"given name in its parent’s context, another level in the name space is "
"needed, which according to the addressing semantics implies the existence of "
"an actor with the router’s name. This is not only necessary for the internal "
"messaging involved in creating, restarting and terminating actors, it is "
"also needed when the pooled actors need to converse with other actors and "
"receive replies in a deterministic fashion. Since each actor knows its own "
"external representation as well as that of its parent, the routees decide "
"where replies should be sent when reacting to a message:"
msgstr ""

# ddcdd7289e2b44e3830f6cdd82fc1431
#: ../../scala/routing.rst:97
msgid ""
"It is apparent now why routing needs to be enabled in code rather than being "
"possible to “bolt on” later: whether or not an actor is routed means a "
"change to the actor hierarchy, changing the actor paths of all children of "
"the router. The routees especially do need to know that they are routed to "
"in order to choose the sender reference for any messages they dispatch as "
"shown above."
msgstr ""

# 7eb344d489c74ab1a5f2d93073ab30a8
#: ../../scala/routing.rst:104
msgid "Routers vs. Supervision"
msgstr ""

# 8a2f456c4d71440bb39a6729eea9f055
#: ../../scala/routing.rst:106
msgid ""
"As explained in the previous section, routers create new actor instances as "
"children of the “head” router, who therefor also is their supervisor. The "
"supervisor strategy of this actor can be configured by means of the :meth:"
"`RouterConfig.supervisorStrategy` property, which is supported for all built-"
"in router types. It defaults to “always escalate”, which leads to the "
"application of the router’s parent’s supervision directive to all children "
"of the router uniformly (i.e. not only the one which failed). It should be "
"mentioned that the router overrides the default behavior of terminating all "
"children upon restart, which means that a restart—while re-creating them—"
"does not have an effect on the number of actors in the pool."
msgstr ""

# 7248ddf1b6bd44d8a471a9a32bac2008
#: ../../scala/routing.rst:117
msgid "Setting the strategy is easily done:"
msgstr ""

# 8428ddfec7ef4a4aa661bf0b99292490
#: ../../scala/routing.rst:123
msgid ""
"Another potentially useful approach is to give the router the same strategy "
"as its parent, which effectively treats all actors in the pool as if they "
"were direct children of their grand-parent instead."
msgstr ""

# a3d83d30ed5e4d03ae5384249f0e908b
#: ../../scala/routing.rst:128
msgid "Router usage"
msgstr ""

# 2865862db62f473d87df282a85b68bcd
#: ../../scala/routing.rst:130
msgid ""
"In this section we will describe how to use the different router types. "
"First we need to create some actors that will be used in the examples:"
msgstr ""

# 8a1c6067fa3d4807a02684a06df4c0ab
#: ../../scala/routing.rst:135
msgid "and"
msgstr ""

# 2d5b03a1be3042f7a2afd07001eeaa7f
#: ../../scala/routing.rst:141
msgid "RoundRobinRouter"
msgstr ""

# 45b48440a3e541c6a59fcb8d9d12854c
#: ../../scala/routing.rst:142
msgid ""
"Routes in a `round-robin <http://en.wikipedia.org/wiki/Round-robin>`_ "
"fashion to its routees. Code example:"
msgstr ""

# 09c49a06519849f7a1004f2f459437ec
# 8bc7de988a564b0eabb6e2e255e5286f
# d1cfcdacb36a41e89d92474d9016660b
#: ../../scala/routing.rst:147 ../../scala/routing.rst:176
#: ../../scala/routing.rst:216
msgid "When run you should see a similar output to this:"
msgstr ""

# 9f26fc26c70c4e3582b92daf7a711e40
#: ../../scala/routing.rst:162
msgid ""
"If you look closely to the output you can see that each of the routees "
"received two messages which is exactly what you would expect from a round-"
"robin router to happen. (The name of an actor is automatically created in "
"the format ``$letter`` unless you specify it - hence the names printed "
"above.)"
msgstr ""

# c3aa26cca7454e58a80a5cc06effe78d
#: ../../scala/routing.rst:168
msgid "RandomRouter"
msgstr ""

# 9c5e589caad24046b6e27e004507b305
#: ../../scala/routing.rst:169
msgid ""
"As the name implies this router type selects one of its routees randomly and "
"forwards the message it receives to this routee. This procedure will happen "
"each time it receives a message. Code example:"
msgstr ""

# f1541e9ceb08410bb2fb57e410879426
#: ../../scala/routing.rst:191
msgid ""
"The result from running the random router should be different, or at least "
"random, every time you run it. Try to run it a couple of times to verify its "
"behavior if you don't trust us."
msgstr ""

# aaddc309215842f09d73cf28cbee924c
#: ../../scala/routing.rst:195
msgid "SmallestMailboxRouter"
msgstr ""

# d51e25bcb6bb457b9ca51b826dd13531
#: ../../scala/routing.rst:196
msgid ""
"A Router that tries to send to the non-suspended routee with fewest messages "
"in mailbox. The selection is done in this order:"
msgstr ""

# d5d137aa51ff4d94b3043129b2408e0f
#: ../../scala/routing.rst:199
msgid "pick any idle routee (not processing message) with empty mailbox"
msgstr ""

# 97d1dbe7fe4140de89c908b816b11833
#: ../../scala/routing.rst:200
msgid "pick any routee with empty mailbox"
msgstr ""

# 4bde85780ba64364bd675e65a4010468
#: ../../scala/routing.rst:201
msgid "pick routee with fewest pending messages in mailbox"
msgstr ""

# 8c694ff9bb4b4352b6e8d1818ce8dfed
#: ../../scala/routing.rst:202
msgid ""
"pick any remote routee, remote actors are consider lowest priority, since "
"their mailbox size is unknown"
msgstr ""

# 584721c74380415fa51ce91e1bfb89c6
#: ../../scala/routing.rst:205
msgid "Code example:"
msgstr ""

# bc6e332cf6214aeab63df6ef4c87f84a
#: ../../scala/routing.rst:210
msgid "BroadcastRouter"
msgstr ""

# 7cbe1fd56b334163b5071d65aa5c5cb3
#: ../../scala/routing.rst:211
msgid ""
"A broadcast router forwards the message it receives to *all* its routees. "
"Code example:"
msgstr ""

# 4e408722b154434b9b6fa12c8a65bf57
#: ../../scala/routing.rst:226
msgid ""
"As you can see here above each of the routees, five in total, received the "
"broadcast message."
msgstr ""

# 55446d32f85d43bc889abd9ada34c307
#: ../../scala/routing.rst:229
msgid "ScatterGatherFirstCompletedRouter"
msgstr ""

# 15f33a9a15a34e59ac696b52186f115e
#: ../../scala/routing.rst:230
msgid ""
"The ScatterGatherFirstCompletedRouter will send the message on to all its "
"routees as a future. It then waits for first result it gets back. This "
"result will be sent back to original sender. Code example:"
msgstr ""

# 76ba6046b78145a3bde7a3dfaead1eaf
#: ../../scala/routing.rst:236
msgid "When run you should see this:"
msgstr ""

# 432bb9c053a14009b5c7a0ddb6791d13
#: ../../scala/routing.rst:242
msgid ""
"From the output above you can't really see that all the routees performed "
"the calculation, but they did! The result you see is from the first routee "
"that returned its calculation to the router."
msgstr ""

# b003a7aef4544df0a45ceacc92a1e773
#: ../../scala/routing.rst:246
msgid "Broadcast Messages"
msgstr ""

# 3fb32ed65fba4859985cde178928bd2c
#: ../../scala/routing.rst:248
msgid ""
"There is a special type of message that will be sent to all routees "
"regardless of the router. This message is called ``Broadcast`` and is used "
"in the following manner:"
msgstr ""

# ad435e9830c54aabb6fdadaced5f4ab8
#: ../../scala/routing.rst:255
msgid ""
"Only the actual message is forwarded to the routees, i.e. \"Watch out for "
"Davy Jones' locker\" in the example above. It is up to the routee "
"implementation whether to handle the broadcast message or not."
msgstr ""

# 0bd094714f8d4018b3cfcd6698acdaa0
#: ../../scala/routing.rst:259
msgid "Dynamically Resizable Routers"
msgstr ""

# edcdc2d724c14c6a8b4a8b7cc2a6af3d
#: ../../scala/routing.rst:261
msgid ""
"All routers can be used with a fixed number of routees or with a resize "
"strategy to adjust the number of routees dynamically."
msgstr ""

# 041860f20600426aade762370ad11c23
#: ../../scala/routing.rst:264
msgid ""
"This is an example of how to create a resizable router that is defined in "
"configuration:"
msgstr ""

# 485b951b5bfb475e80b1c333c3f711ce
#: ../../scala/routing.rst:270
msgid ""
"Several more configuration options are available and described in ``akka."
"actor.deployment.default.resizer`` section of the reference :ref:"
"`configuration`."
msgstr ""

# 7a3f7aa516cb4a5f9d843bc4d36616be
#: ../../scala/routing.rst:273
msgid ""
"This is an example of how to programmatically create a resizable router:"
msgstr ""

# 6bcda13e9c3747caa331b7d2016b80d2
#: ../../scala/routing.rst:277
msgid ""
"*It is also worth pointing out that if you define the ``router`` in the "
"configuration file then this value will be used instead of any "
"programmatically sent parameters.*"
msgstr ""

# d8c8392f874947848a0c1fbd63bdcf08
#: ../../scala/routing.rst:282
msgid ""
"Resizing is triggered by sending messages to the actor pool, but it is not "
"completed synchronously; instead a message is sent to the “head” :class:"
"`Router` to perform the size change. Thus you cannot rely on resizing to "
"instantaneously create new workers when all others are busy, because the "
"message just sent will be queued to the mailbox of a busy actor. To remedy "
"this, configure the pool to use a balancing dispatcher, see `Configuring "
"Dispatchers`_ for more information."
msgstr ""

# aa13756b6cb248c2bd5a244c177f0be0
#: ../../scala/routing.rst:291
msgid "Custom Router"
msgstr ""

# 52635d2e7ff142a4972f33fbb2df02c0
#: ../../scala/routing.rst:293
msgid ""
"You can also create your own router should you not find any of the ones "
"provided by Akka sufficient for your needs. In order to roll your own router "
"you have to fulfill certain criteria which are explained in this section."
msgstr ""

# abe3acbe698b4b76b7743242d18f16a8
#: ../../scala/routing.rst:296
msgid ""
"The router created in this example is a simple vote counter. It will route "
"the votes to specific vote counter actors. In this case we only have two "
"parties the Republicans and the Democrats. We would like a router that "
"forwards all democrat related messages to the Democrat actor and all "
"republican related messages to the Republican actor."
msgstr ""

# d43e3d7f08c64c4b8ae48b598fbdbbd1
#: ../../scala/routing.rst:300
msgid "We begin with defining the class:"
msgstr ""

# c9717b3e39484329b3dffa9a2779d0a0
#: ../../scala/routing.rst:305
msgid ""
"The next step is to implement the ``createRoute`` method in the class just "
"defined:"
msgstr ""

# 7dc0916802c64f2fb27caba5c359fc79
#: ../../scala/routing.rst:309
msgid ""
"As you can see above we start off by creating the routees and put them in a "
"collection."
msgstr ""

# 4297b23ae3d04b149043eb6a9b2aaf7a
#: ../../scala/routing.rst:311
msgid ""
"Make sure that you don't miss to implement the line below as it is *really* "
"important. It registers the routees internally and failing to call this "
"method will cause a ``ActorInitializationException`` to be thrown when the "
"router is used. Therefore always make sure to do the following in your "
"custom router:"
msgstr ""

# ccab1bebde0c4240ad203aebdbaf9495
#: ../../scala/routing.rst:318
msgid ""
"The routing logic is where your magic sauce is applied. In our example it "
"inspects the message types and forwards to the correct routee based on this:"
msgstr ""

# b3cdc688a3e94a49b82851893b38d960
#: ../../scala/routing.rst:323
msgid ""
"As you can see above what's returned in the partial function is a ``List`` "
"of ``Destination(sender, routee)``. The sender is what \"parent\" the routee "
"should see - changing this could be useful if you for example want another "
"actor than the original sender to intermediate the result of the routee (if "
"there is a result). For more information about how to alter the original "
"sender we refer to the source code of `ScatterGatherFirstCompletedRouter "
"<https://github.com/akka/akka/blob/master/akka-actor/src/main/scala/akka/"
"routing/Routing.scala#L375>`_"
msgstr ""

# 6426833100ce44db9e145962172daddd
#: ../../scala/routing.rst:329
msgid "All in all the custom router looks like this:"
msgstr ""

# cd4206803e654cf8b7c9958650225f93
#: ../../scala/routing.rst:333
msgid ""
"If you are interested in how to use the VoteCountRouter you can have a look "
"at the test class `RoutingSpec <https://github.com/akka/akka/blob/master/"
"akka-actor-tests/src/test/scala/akka/routing/RoutingSpec.scala>`_"
msgstr ""

# 6ce607addf2f437db04f876bee55b370
#: ../../scala/routing.rst:337
msgid "Configured Custom Router"
msgstr ""

# 2057999b0efe46839c35c24baf92ac83
#: ../../scala/routing.rst:339
msgid ""
"It is possible to define configuration properties for custom routers. In the "
"``router`` property of the deployment configuration you define the fully "
"qualified class name of the router class. The router class must extend "
"``akka.routing.RouterConfig`` and and have constructor with ``com.typesafe."
"config.Config`` parameter. The deployment section of the configuration is "
"passed to the constructor."
msgstr ""

# 38b9b9e25cd941f89c509dc152e0530b
#: ../../scala/routing.rst:345
msgid "Custom Resizer"
msgstr ""

# 2fd2c0bc221f48ff9c2bdf4528f8e721
#: ../../scala/routing.rst:347
msgid ""
"A router with dynamically resizable number of routees is implemented by "
"providing a ``akka.routing.Resizer`` in ``resizer`` method of the "
"``RouterConfig``. See ``akka.routing.DefaultResizer`` for inspiration of how "
"to write your own resize strategy."
msgstr ""

# 6798b4f1003242cfb5a7c12bb33b8fdd
#: ../../scala/routing.rst:352
msgid "Configuring Dispatchers"
msgstr ""

# 6129cdf1f4974c4db47f5a5e96c6209a
#: ../../scala/routing.rst:354
msgid ""
"The dispatcher for created children of the router will be taken from :class:"
"`Props` as described in :ref:`dispatchers-scala`. For a dynamic pool it "
"makes sense to configure the :class:`BalancingDispatcher` if the precise "
"routing is not so important (i.e. no consistent hashing or round-robin is "
"required); this enables newly created routees to pick up work immediately by "
"stealing it from their siblings."
msgstr ""

# c564b0e7b1da46feb946765745de7d55
#: ../../scala/routing.rst:361
msgid ""
"The “head” router, of course, cannot run on the same balancing dispatcher, "
"because it does not process the same messages, hence this special actor does "
"not use the dispatcher configured in :class:`Props`, but takes the "
"``routerDispatcher`` from the :class:`RouterConfig` instead, which defaults "
"to the actor system’s default dispatcher. All standard routers allow setting "
"this property in their constructor or factory method, custom routers have to "
"implement the method in a suitable way."
msgstr ""

# 748038ec63b745b2b7d8a7875d086824
#: ../../scala/scheduler.rst:6
msgid "Scheduler (Scala)"
msgstr ""

# 1c9562c25b8849bd94ee6bc5ecb9cc67
#: ../../scala/scheduler.rst:8
msgid ""
"Sometimes the need for making things happen in the future arises, and where "
"do you go look then? Look no further than ``ActorSystem``! There you find "
"the :meth:`scheduler` method that returns an instance of akka.actor."
"Scheduler, this instance is unique per ActorSystem and is used internally "
"for scheduling things to happen at specific points in time. Please note that "
"the scheduled tasks are executed by the default ``MessageDispatcher`` of the "
"``ActorSystem``."
msgstr ""

# 1e6520b760f448c3a55553dde1c354f3
#: ../../scala/scheduler.rst:14
msgid ""
"You can schedule sending of messages to actors and execution of tasks "
"(functions or Runnable). You will get a ``Cancellable`` back that you can "
"call :meth:`cancel` on to cancel the execution of the scheduled operation."
msgstr ""

# efc8d67e303241508f2b547b97378a43
#: ../../scala/scheduler.rst:19
msgid "Some examples"
msgstr ""

# 4a404a96ae684674a487ff4d1359227b
#: ../../scala/scheduler.rst:31
msgid "From ``akka.actor.ActorSystem``"
msgstr ""

# 24f52439cc024f979851ba0ebfd9fcf1
#: ../../scala/scheduler.rst:38
msgid "The Scheduler interface"
msgstr ""

# 8bce553ce124400e892418cc21e3a661
#: ../../scala/scheduler.rst:44
msgid "The Cancellable interface"
msgstr ""

# a0f4687bde2e439bb82726f719bfb302
#: ../../scala/scheduler.rst:46
msgid ""
"This allows you to ``cancel`` something that has been scheduled for "
"execution."
msgstr ""

# 9905db2f06da40faabd0cba4bfdc8025
#: ../../scala/scheduler.rst:49
msgid ""
"This does not abort the execution of the task, if it had already been "
"started."
msgstr ""

# fa82230772ab40629a19cc8bbfa0787a
#: ../../scala/serialization.rst:6
msgid "Serialization (Scala)"
msgstr ""

# b9221d404ff64a33b6ee842d3bd23a6a
#: ../../scala/serialization.rst:8
msgid ""
"Akka has a built-in Extension for serialization, and it is both possible to "
"use the built-in serializers and to write your own."
msgstr ""

# 0a64a46d4ab64a16af799ef691a84fbc
#: ../../scala/serialization.rst:11
msgid ""
"The serialization mechanism is both used by Akka internally to serialize "
"messages, and available for ad-hoc serialization of whatever you might need "
"it for."
msgstr ""

# 324935241a7b4b768a3c9dacc7a9eac0
#: ../../scala/serialization.rst:15
msgid "Usage"
msgstr ""

# e745cc8994e145e7b4885e4d9865666b
#: ../../scala/serialization.rst:18
msgid "Configuration"
msgstr ""

# a571275e0aea44ad8dd47af691500806
#: ../../scala/serialization.rst:20
msgid ""
"For Akka to know which ``Serializer`` to use for what, you need edit your :"
"ref:`configuration`, in the \"akka.actor.serializers\"-section you bind "
"names to implementations of the ``akka.serialization.Serializer`` you wish "
"to use, like this:"
msgstr ""

# a2af62f143c34a9ab0b0d28d37a3e6f6
#: ../../scala/serialization.rst:26
msgid ""
"After you've bound names to different implementations of ``Serializer`` you "
"need to wire which classes should be serialized using which ``Serializer``, "
"this is done in the \"akka.actor.serialization-bindings\"-section:"
msgstr ""

# 5bac7c3095b64a60a3806291544e8551
#: ../../scala/serialization.rst:31
msgid ""
"You only need to specify the name of an interface or abstract base class of "
"the messages. In case of ambiguity, i.e. the message implements several of "
"the configured classes, the most specific configured class will be used, i."
"e. the one of which all other candidates are superclasses. If this condition "
"cannot be met, because e.g. ``java.io.Serializable`` and "
"``MyOwnSerializable`` both apply and neither is a subtype of the other, a "
"warning will be issued"
msgstr ""

# 39a816ba3b7e404b8fc67c678c6f1d4d
#: ../../scala/serialization.rst:38
msgid ""
"Akka provides serializers for :class:`java.io.Serializable` and `protobuf "
"<http://code.google.com/p/protobuf/>`_ :class:`com.google.protobuf."
"GeneratedMessage` by default (the latter only if depending on the akka-"
"remote module), so normally you don't need to add configuration for that; "
"since :class:`com.google.protobuf.GeneratedMessage` implements :class:`java."
"io.Serializable`, protobuf messages will always by serialized using the "
"protobuf protocol unless specifically overridden. In order to disable a "
"default serializer, map its marker type to “none”::"
msgstr ""

# 1e30e587781849be962b6ef54eba3e90
#: ../../scala/serialization.rst:52
msgid "Verification"
msgstr ""

# 3ec2720b316c4ab7b5194d59d2b83022
#: ../../scala/serialization.rst:54
msgid ""
"If you want to verify that your messages are serializable you can enable the "
"following config option:"
msgstr ""

# 2057bbe409ad4642a95dea2975d34a45
# 81ad1aa8fb2144f49f301c6a9517caff
#: ../../scala/serialization.rst:60 ../../scala/serialization.rst:69
msgid ""
"We only recommend using the config option turned on when you're running "
"tests. It is completely pointless to have it turned on in other scenarios."
msgstr ""

# f649d2a7d4854d5b883a839e8ad649e7
#: ../../scala/serialization.rst:63
msgid ""
"If you want to verify that your ``Props`` are serializable you can enable "
"the following config option:"
msgstr ""

# 9c303d83b13a45c38688d94ca38cfe72
#: ../../scala/serialization.rst:73
msgid "Programmatic"
msgstr ""

# da7270ab8f9e47b1bf31408206a7afd4
#: ../../scala/serialization.rst:75
msgid ""
"If you want to programmatically serialize/deserialize using Akka "
"Serialization, here's some examples:"
msgstr ""

# a5e8e7c0237c460cac4d7d6674e8e27c
#: ../../scala/serialization.rst:81
msgid ""
"For more information, have a look at the ``ScalaDoc`` for ``akka."
"serialization._``"
msgstr ""

# 236b2a0dda90432598fdf31b88fb8e66
#: ../../scala/serialization.rst:84
msgid "Customization"
msgstr ""

# 3cc3a6ff1b87482aaec4646c607d94d0
#: ../../scala/serialization.rst:86
msgid ""
"So, lets say that you want to create your own ``Serializer``, you saw the "
"``akka.docs.serialization.MyOwnSerializer`` in the config example above?"
msgstr ""

# 8e1b0dd6296f4edebbe2ddc677c4e0d6
#: ../../scala/serialization.rst:90
msgid "Creating new Serializers"
msgstr ""

# 5ea3da1dfc184283a1733e963b286c6f
#: ../../scala/serialization.rst:92
msgid ""
"First you need to create a class definition of your ``Serializer`` like so:"
msgstr ""

# dc38ed57b8104f97935ead35ed932916
#: ../../scala/serialization.rst:98
msgid ""
"Then you only need to fill in the blanks, bind it to a name in your :ref:"
"`configuration` and then list which classes that should be serialized using "
"it."
msgstr ""

# 48d7049a761b4c7dac89f9f7dc830c7f
#: ../../scala/serialization.rst:102
msgid "Serializing ActorRefs"
msgstr ""

# ff7c2187f69648eb96c791815a4d4fc2
#: ../../scala/serialization.rst:104
msgid ""
"All ActorRefs are serializable using JavaSerializer, but in case you are "
"writing your own serializer, you might want to know how to serialize and "
"deserialize them properly, here's the magic incantation:"
msgstr ""

# 26b1918262834613a3059b01b9f12943
#: ../../scala/serialization.rst:111
msgid "A Word About Java Serialization"
msgstr ""

# 8e1da7437b6e474887f87d7886fe1056
#: ../../scala/serialization.rst:113
msgid ""
"When using Java serialization without employing the :class:`JavaSerializer` "
"for the task, you must make sure to supply a valid :class:"
"`ExtendedActorSystem` in the dynamic variable ``JavaSerializer."
"currentSystem``. This is used when reading in the representation of an :"
"class:`ActorRef` for turning the string representation into a real "
"reference. :class:`DynamicVariable` is a thread-local variable, so be sure "
"to have it set while deserializing anything which might contain actor "
"references."
msgstr ""

# 3c7bc52e38634ff09443a007c0fe6712
#: ../../scala/stm.rst:6
msgid "Software Transactional Memory (Scala)"
msgstr ""

# adf32fe9ed65428ab393d76f1e090e54
#: ../../scala/stm.rst:10
msgid "Overview of STM"
msgstr ""

# 898f11e84b124d7b8402662dabb1b443
#: ../../scala/stm.rst:12
msgid ""
"An `STM <http://en.wikipedia.org/wiki/Software_transactional_memory>`_ turns "
"the Java heap into a transactional data set with begin/commit/rollback "
"semantics. Very much like a regular database. It implements the first three "
"letters in `ACID`_; ACI:"
msgstr ""

# b71c90ee3f4a436cab4373ec9d2a12f2
#: ../../scala/stm.rst:17
msgid "Atomic"
msgstr ""

# 7f6b1f04434541c59f0a6cb6c13ca918
#: ../../scala/stm.rst:18
msgid "Consistent"
msgstr ""

# d5f18157f5f24ef986ce9f11cffd6eb2
#: ../../scala/stm.rst:19
msgid "Isolated"
msgstr ""

# 6332651187b74942ab1f85bb52dc81a8
# 378a3b98aec241e6bfcba98cbdb1672d
#: ../../scala/stm.rst:23 ../../scala/transactors.rst:31
msgid ""
"Generally, the STM is not needed very often when working with Akka. Some use-"
"cases (that we can think of) are:"
msgstr ""

# 6e15d568501b4870ae6a8ffc10d69efc
#: ../../scala/stm.rst:26
msgid ""
"When you really need composable message flows across many actors updating "
"their **internal local** state but need them to do that atomically in one "
"big transaction. Might not be often, but when you do need this then you are "
"screwed without it."
msgstr ""

# 901160812ffb4c618c924ed611ee7c11
# e3a598322bc54954aa9243d85defd4e1
#: ../../scala/stm.rst:30 ../../scala/transactors.rst:39
msgid "When you want to share a datastructure across actors."
msgstr ""

# d3793400b98d488f9775e71522569a50
#: ../../scala/stm.rst:32
msgid ""
"The use of STM in Akka is inspired by the concepts and views in `Clojure`_"
"\\'s STM. Please take the time to read `this excellent document`_ about "
"state in clojure and view `this presentation`_ by Rich Hickey (the genius "
"behind Clojure)."
msgstr ""

# ec056804d31349aaa91a060119401d2d
#: ../../scala/stm.rst:43
msgid "Scala STM"
msgstr ""

# 2790a558fc9a47768cd3d00772c89faf
#: ../../scala/stm.rst:45
msgid ""
"The STM supported in Akka is `ScalaSTM`_ which will be soon included in the "
"Scala standard library."
msgstr ""

# 8f89d09b2bf54acb98133db2d5c5ae03
#: ../../scala/stm.rst:50
msgid ""
"The STM is based on Transactional References (referred to as Refs). Refs are "
"memory cells, holding an (arbitrary) immutable value, that implement CAS "
"(Compare-And-Swap) semantics and are managed and enforced by the STM for "
"coordinated changes across many Refs."
msgstr ""

# c0cfa41929094141a3f92b367bf1963c
#: ../../scala/stm.rst:57
msgid "Persistent Datastructures"
msgstr ""

# a5495b68cf1a4001a63d48ce7fec30e1
#: ../../scala/stm.rst:59
msgid ""
"Working with immutable collections can sometimes give bad performance due to "
"extensive copying. Scala provides so-called persistent datastructures which "
"makes working with immutable collections fast. They are immutable but with "
"constant time access and modification. They use structural sharing and an "
"insert or update does not ruin the old structure, hence \"persistent\". "
"Makes working with immutable composite types fast. The persistent "
"datastructures currently consist of a `Map`_ and `Vector`_."
msgstr ""

# 41346d2326fb49f882c5a2e413d019fc
#: ../../scala/stm.rst:72
msgid "Integration with Actors"
msgstr ""

# d1c3a1c19eac4c1faf7c4ac2b31b3576
#: ../../scala/stm.rst:74
msgid ""
"In Akka we've also integrated Actors and STM in :ref:`agents-scala` and :ref:"
"`transactors-scala`."
msgstr ""

# e108ed4210294992acedea2e7dbd9c47
#: ../../scala/testing.rst:5
msgid "Testing Actor Systems (Scala)"
msgstr ""

# 36fe9a2ec7924e2cb0f1fb0da98ec9a0
#: ../../scala/testing.rst:11
msgid ""
"As with any piece of software, automated tests are a very important part of "
"the development cycle. The actor model presents a different view on how "
"units of code are delimited and how they interact, which has an influence on "
"how to perform tests."
msgstr ""

# 21b102f7a80445a6aa7f944f5080f6d1
#: ../../scala/testing.rst:16
msgid ""
"Akka comes with a dedicated module :mod:`akka-testkit` for supporting tests "
"at different levels, which fall into two clearly distinct categories:"
msgstr ""

# fbd0406e20be4a0698201b7efc8e63d7
#: ../../scala/testing.rst:19
msgid ""
"Testing isolated pieces of code without involving the actor model, meaning "
"without multiple threads; this implies completely deterministic behavior "
"concerning the ordering of events and no concurrency concerns and will be "
"called **Unit Testing** in the following."
msgstr ""

# 1274d9b9279a4002b2a48daf96909077
#: ../../scala/testing.rst:23
msgid ""
"Testing (multiple) encapsulated actors including multi-threaded scheduling; "
"this implies non-deterministic order of events but shielding from "
"concurrency concerns by the actor model and will be called **Integration "
"Testing** in the following."
msgstr ""

# a8ec9a4e13ab4cbaa914d93b9a6d3ba1
#: ../../scala/testing.rst:28
msgid ""
"There are of course variations on the granularity of tests in both "
"categories, where unit testing reaches down to white-box tests and "
"integration testing can encompass functional tests of complete actor "
"networks. The important distinction lies in whether concurrency concerns are "
"part of the test or not. The tools offered are described in detail in the "
"following sections."
msgstr ""

# c85da0a576474c10a49a0b4f857a9fbc
#: ../../scala/testing.rst:36
msgid "Be sure to add the module :mod:`akka-testkit` to your dependencies."
msgstr ""

# 2376daea60f341169c71855b7e1484f2
#: ../../scala/testing.rst:39
msgid "Unit Testing with :class:`TestActorRef`"
msgstr ""

# 2b24d677b0664938aed43bada19d327a
#: ../../scala/testing.rst:41
msgid ""
"Testing the business logic inside :class:`Actor` classes can be divided into "
"two parts: first, each atomic operation must work in isolation, then "
"sequences of incoming events must be processed correctly, even in the "
"presence of some possible variability in the ordering of events. The former "
"is the primary use case for single-threaded unit testing, while the latter "
"can only be verified in integration tests."
msgstr ""

# 42f896414c00410b8527094f8496a0ce
#: ../../scala/testing.rst:48
msgid ""
"Normally, the :class:`ActorRef` shields the underlying :class:`Actor` "
"instance from the outside, the only communications channel is the actor's "
"mailbox. This restriction is an impediment to unit testing, which led to the "
"inception of the :class:`TestActorRef`. This special type of reference is "
"designed specifically for test purposes and allows access to the actor in "
"two ways: either by obtaining a reference to the underlying actor instance, "
"or by invoking or querying the actor's behaviour (:meth:`receive`). Each one "
"warrants its own section below."
msgstr ""

# 95ba1acd776c40228c0ec00a9314b10f
#: ../../scala/testing.rst:58
msgid "Obtaining a Reference to an :class:`Actor`"
msgstr ""

# 079d27b4c2124824acc5272981afac61
#: ../../scala/testing.rst:60
msgid ""
"Having access to the actual :class:`Actor` object allows application of all "
"traditional unit testing techniques on the contained methods. Obtaining a "
"reference is done like this:"
msgstr ""

# 61efc83083e44a908eaa1332c93c5eac
#: ../../scala/testing.rst:66
msgid ""
"Since :class:`TestActorRef` is generic in the actor type it returns the "
"underlying actor with its proper static type. From this point on you may "
"bring any unit testing tool to bear on your actor as usual."
msgstr ""

# 0b33e6f408554dc18fffcaa9e80459f2
# 23c1d3fd438f4bb7a759697af52fa256
#: ../../scala/testing.rst:71 ../../scala/testing.rst:331
msgid "Expecting Exceptions"
msgstr ""

# ecedaaa8a99349d6af66af240d4437e4
#: ../../scala/testing.rst:73
msgid ""
"Testing that an expected exception is thrown while processing a message sent "
"to the actor under test can be done by using a :class:`TestActorRef` :meth:"
"`receive` based invocation:"
msgstr ""

# 8eba5a014bd245e49ea255b79a7bff21
#: ../../scala/testing.rst:82
msgid "Testing Finite State Machines"
msgstr ""

# 3e1f996621e94e218e871e92cca5eb46
#: ../../scala/testing.rst:84
msgid ""
"If your actor under test is a :class:`FSM`, you may use the special :class:"
"`TestFSMRef` which offers all features of a normal :class:`TestActorRef` and "
"in addition allows access to the internal state:"
msgstr ""

# a708cfd9d43e42518438283473406ec3
#: ../../scala/testing.rst:90
msgid ""
"Due to a limitation in Scala’s type inference, there is only the factory "
"method shown above, so you will probably write code like ``TestFSMRef(new "
"MyFSM)`` instead of the hypothetical :class:`ActorRef`-inspired ``TestFSMRef"
"[MyFSM]``. All methods shown above directly access the FSM state without any "
"synchronization; this is perfectly alright if the :class:"
"`CallingThreadDispatcher` is used (which is the default for :class:"
"`TestFSMRef`) and no other threads are involved, but it may lead to "
"surprises if you were to actually exercise timer events, because those are "
"executed on the :obj:`Scheduler` thread."
msgstr ""

# 6526f35779a647fd89cab01ab142866e
#: ../../scala/testing.rst:101
msgid "Testing the Actor's Behavior"
msgstr ""

# f594766314aa457a9a17203bbba59bff
#: ../../scala/testing.rst:103
msgid ""
"When the dispatcher invokes the processing behavior of an actor on a "
"message, it actually calls :meth:`apply` on the current behavior registered "
"for the actor. This starts out with the return value of the declared :meth:"
"`receive` method, but it may also be changed using :meth:`become` and :meth:"
"`unbecome` in response to external messages. All of this contributes to the "
"overall actor behavior and it does not lend itself to easy testing on the :"
"class:`Actor` itself. Therefore the :class:`TestActorRef` offers a different "
"mode of operation to complement the :class:`Actor` testing: it supports all "
"operations also valid on normal :class:`ActorRef`. Messages sent to the "
"actor are processed synchronously on the current thread and answers may be "
"sent back as usual. This trick is made possible by the :class:"
"`CallingThreadDispatcher` described below; this dispatcher is set implicitly "
"for any actor instantiated into a :class:`TestActorRef`."
msgstr ""

# 143bb4b661604c29a48d71167869ef79
#: ../../scala/testing.rst:119
msgid ""
"As the :class:`TestActorRef` is a subclass of :class:`LocalActorRef` with a "
"few special extras, also aspects like supervision and restarting work "
"properly, but beware that execution is only strictly synchronous as long as "
"all actors involved use the :class:`CallingThreadDispatcher`. As soon as you "
"add elements which include more sophisticated scheduling you leave the realm "
"of unit testing as you then need to think about asynchronicity again (in "
"most cases the problem will be to wait until the desired effect had a chance "
"to happen)."
msgstr ""

# 33341a8ef17b4936bc10bb7f755d75f5
#: ../../scala/testing.rst:127
msgid ""
"One more special aspect which is overridden for single-threaded tests is "
"the :meth:`receiveTimeout`, as including that would entail asynchronous "
"queuing of :obj:`ReceiveTimeout` messages, violating the synchronous "
"contract."
msgstr ""

# bd355b8cb32549e4a6fe1812391875bd
#: ../../scala/testing.rst:133
msgid ""
"To summarize: :class:`TestActorRef` overwrites two fields: it sets the "
"dispatcher to :obj:`CallingThreadDispatcher.global` and it sets the :obj:"
"`receiveTimeout` to None."
msgstr ""

# 966f69abefb84a19a8b8cbc5ac69099f
#: ../../scala/testing.rst:138
msgid "The Way In-Between"
msgstr ""

# 97024daa8f1648e99860a7d2245d63b7
#: ../../scala/testing.rst:140
msgid ""
"If you want to test the actor behavior, including hotswapping, but without "
"involving a dispatcher and without having the :class:`TestActorRef` swallow "
"any thrown exceptions, then there is another mode available for you: just "
"use the :meth:`receive` method :class:`TestActorRef`, which will be "
"forwarded to the underlying actor:"
msgstr ""

# 6e7f39d6d9ec4a1c8b5b1b5ccd9cf03b
#: ../../scala/testing.rst:148
msgid ""
"The above sample assumes the default behavior for unhandled messages, i.e. "
"that the actor doesn't swallow all messages and doesn't override :meth:"
"`unhandled`."
msgstr ""

# aac67c72b9d54069befd0666ad048d54
#: ../../scala/testing.rst:152
msgid "Use Cases"
msgstr ""

# b7efc81f304c48349770d0333028ded3
#: ../../scala/testing.rst:154
msgid ""
"You may of course mix and match both modi operandi of :class:`TestActorRef` "
"as suits your test needs:"
msgstr ""

# 60e0915e4cf444efaf1cbb6f93603526
#: ../../scala/testing.rst:157
msgid ""
"one common use case is setting up the actor into a specific internal state "
"before sending the test message"
msgstr ""

# d4866904cd224aea8bc135e864170e13
#: ../../scala/testing.rst:159
msgid ""
"another is to verify correct internal state transitions after having sent "
"the test message"
msgstr ""

# 84aa8a4c213849e08797f153285c9b35
#: ../../scala/testing.rst:162
msgid ""
"Feel free to experiment with the possibilities, and if you find useful "
"patterns, don't hesitate to let the Akka forums know about them! Who knows, "
"common operations might even be worked into nice DSLs."
msgstr ""

# 292e63aaf93748eea2d8858987f6a50b
#: ../../scala/testing.rst:167
msgid "Integration Testing with :class:`TestKit`"
msgstr ""

# aa6bcb84ee134c5b868fefc444ce02e6
#: ../../scala/testing.rst:169
msgid ""
"When you are reasonably sure that your actor's business logic is correct, "
"the next step is verifying that it works correctly within its intended "
"environment (if the individual actors are simple enough, possibly because "
"they use the :mod:`FSM` module, this might also be the first step). The "
"definition of the environment depends of course very much on the problem at "
"hand and the level at which you intend to test, ranging for functional/"
"integration tests to full system tests. The minimal setup consists of the "
"test procedure, which provides the desired stimuli, the actor under test, "
"and an actor receiving replies. Bigger systems replace the actor under test "
"with a network of actors, apply stimuli at varying injection points and "
"arrange results to be sent from different emission points, but the basic "
"principle stays the same in that a single procedure drives the test."
msgstr ""

# 5c21308dd1cc4aa28048c5479b257270
#: ../../scala/testing.rst:182
msgid ""
"The :class:`TestKit` class contains a collection of tools which makes this "
"common task easy."
msgstr ""

# 5f5e9982542d4a33a4e4dc2f86a79cff
#: ../../scala/testing.rst:187
msgid ""
"The :class:`TestKit` contains an actor named :obj:`testActor` which is the "
"entry point for messages to be examined with the various ``expectMsg...`` "
"assertions detailed below. When mixing in the trait ``ImplicitSender`` this "
"test actor is implicitly used as sender reference when dispatching messages "
"from the test procedure. The :obj:`testActor` may also be passed to other "
"actors as usual, usually subscribing it as notification listener. There is a "
"whole set of examination methods, e.g. receiving all consecutive messages "
"matching certain criteria, receiving a whole sequence of fixed messages or "
"classes, receiving nothing for some time, etc."
msgstr ""

# 2bcd15c5999b4b77bb122b8c77c9cdb9
#: ../../scala/testing.rst:197
msgid ""
"Remember to shut down the actor system after the test is finished (also in "
"case of failure) so that all actors—including the test actor—are stopped."
msgstr ""

# 19cb36ccdaf84dcb9705a1bad1e5436e
#: ../../scala/testing.rst:201
msgid "Built-In Assertions"
msgstr ""

# 565b01d5e4e446c2af7678427bdcd742
#: ../../scala/testing.rst:203
msgid ""
"The above mentioned :meth:`expectMsg` is not the only method for formulating "
"assertions concerning received messages. Here is the full list:"
msgstr ""

# 078f60918a8641beb405ae5091d5ba8b
#: ../../scala/testing.rst:206
msgid ":meth:`expectMsg[T](d: Duration, msg: T): T`"
msgstr ""

# 3bf86f41c6fc4849bd01d3d75a856799
#: ../../scala/testing.rst:208
msgid ""
"The given message object must be received within the specified time; the "
"object will be returned."
msgstr ""

# 436eb47353174518b844a95549cc48a3
#: ../../scala/testing.rst:211
msgid ":meth:`expectMsgPF[T](d: Duration)(pf: PartialFunction[Any, T]): T`"
msgstr ""

# 606e47f5b0b345a59c92ad9f5cae477c
#: ../../scala/testing.rst:213
msgid ""
"Within the given time period, a message must be received and the given "
"partial function must be defined for that message; the result from applying "
"the partial function to the received message is returned. The duration may "
"be left unspecified (empty parentheses are required in this case) to use the "
"deadline from the innermost enclosing :ref:`within <TestKit.within>` block "
"instead."
msgstr ""

# 02a4e5f33c934882b925e367881c1e19
#: ../../scala/testing.rst:220
msgid ":meth:`expectMsgClass[T](d: Duration, c: Class[T]): T`"
msgstr ""

# 5fc815b782df4aada71c2de968cc74fc
#: ../../scala/testing.rst:222
msgid ""
"An object which is an instance of the given :class:`Class` must be received "
"within the allotted time frame; the object will be returned. Note that this "
"does a conformance check; if you need the class to be equal, have a look at :"
"meth:`expectMsgAllClassOf` with a single given class argument."
msgstr ""

# e75ab771df2f40429c3b79beb80ef0f7
#: ../../scala/testing.rst:227
msgid ":meth:`expectMsgType[T: Manifest](d: Duration)`"
msgstr ""

# 8a7ea4249e5c452d9842a754fc3c9fa7
#: ../../scala/testing.rst:229
msgid ""
"An object which is an instance of the given type (after erasure) must be "
"received within the allotted time frame; the object will be returned. This "
"method is approximately equivalent to ``expectMsgClass(manifest[T].erasure)"
"``."
msgstr ""

# cbba7aae13c94a04ba8f68d4dbc33db9
#: ../../scala/testing.rst:234
msgid ":meth:`expectMsgAnyOf[T](d: Duration, obj: T*): T`"
msgstr ""

# f12b8238aead49a59b5092e4a7e463c0
#: ../../scala/testing.rst:236
msgid ""
"An object must be received within the given time, and it must be equal "
"( compared with ``==``) to at least one of the passed reference objects; the "
"received object will be returned."
msgstr ""

# 15eac8537236415bbcf08d9beff84b82
#: ../../scala/testing.rst:240
msgid ":meth:`expectMsgAnyClassOf[T](d: Duration, obj: Class[_ <: T]*): T`"
msgstr ""

# afb9e2838d1c4c0daefa73ecbe984913
#: ../../scala/testing.rst:242
msgid ""
"An object must be received within the given time, and it must be an instance "
"of at least one of the supplied :class:`Class` objects; the received object "
"will be returned."
msgstr ""

# a0189c04b13e4ba18d2c0b34abd2662f
#: ../../scala/testing.rst:246
msgid ":meth:`expectMsgAllOf[T](d: Duration, obj: T*): Seq[T]`"
msgstr ""

# b2334f9778d54d1a8ad6d6e1e6a84f5d
#: ../../scala/testing.rst:248
msgid ""
"A number of objects matching the size of the supplied object array must be "
"received within the given time, and for each of the given objects there must "
"exist at least one among the received ones which equals (compared with "
"``==``) it. The full sequence of received objects is returned."
msgstr ""

# 4bfa7d306d6440f0b6984e377b1b1f96
#: ../../scala/testing.rst:253
msgid ":meth:`expectMsgAllClassOf[T](d: Duration, c: Class[_ <: T]*): Seq[T]`"
msgstr ""

# 45f4f6e25b45447aa05ea6cf0bc9e627
#: ../../scala/testing.rst:255
msgid ""
"A number of objects matching the size of the supplied :class:`Class` array "
"must be received within the given time, and for each of the given classes "
"there must exist at least one among the received objects whose class equals "
"(compared with ``==``) it (this is *not* a conformance check). The full "
"sequence of received objects is returned."
msgstr ""

# ed06a0e8bfeb47a1bbb36107b3a474fc
#: ../../scala/testing.rst:261
msgid ""
":meth:`expectMsgAllConformingOf[T](d: Duration, c: Class[_ <: T]*): Seq[T]`"
msgstr ""

# cbb8f030ab2e43eab7aa5801e0646c08
#: ../../scala/testing.rst:263
msgid ""
"A number of objects matching the size of the supplied :class:`Class` array "
"must be received within the given time, and for each of the given classes "
"there must exist at least one among the received objects which is an "
"instance of this class. The full sequence of received objects is returned."
msgstr ""

# fef67fa6cdab46baae543ffee635e5f2
#: ../../scala/testing.rst:268
msgid ":meth:`expectNoMsg(d: Duration)`"
msgstr ""

# 9b3d4db0b0554e7daf508439c132115e
#: ../../scala/testing.rst:270
msgid ""
"No message must be received within the given time. This also fails if a "
"message has been received before calling this method which has not been "
"removed from the queue using one of the other methods."
msgstr ""

# cedc3b617411404790d558226f464e95
#: ../../scala/testing.rst:274
msgid ":meth:`receiveN(n: Int, d: Duration): Seq[AnyRef]`"
msgstr ""

# 14de7a2383af441e98ab517d993e2826
#: ../../scala/testing.rst:276
msgid ""
"``n`` messages must be received within the given time; the received messages "
"are returned."
msgstr ""

# ae8141b66a9746a5aefcbb3bb4f2ae70
#: ../../scala/testing.rst:279
msgid ""
":meth:`fishForMessage(max: Duration, hint: String)(pf: PartialFunction[Any, "
"Boolean]): Any`"
msgstr ""

# ed1d7539c94349098057e83b9abde29f
#: ../../scala/testing.rst:281
msgid ""
"Keep receiving messages as long as the time is not used up and the partial "
"function matches and returns ``false``. Returns the message received for "
"which it returned ``true`` or throws an exception, which will include the "
"provided hint for easier debugging."
msgstr ""

# cd3ddddf7558406fafd5c4a788766678
#: ../../scala/testing.rst:286
msgid ""
"In addition to message reception assertions there are also methods which "
"help with message flows:"
msgstr ""

# d26ec2d9ce9449838de53407785afa63
#: ../../scala/testing.rst:289
msgid ":meth:`receiveOne(d: Duration): AnyRef`"
msgstr ""

# 68e7b4cd180f4248bcd5b1883fe48811
#: ../../scala/testing.rst:291
msgid ""
"Tries to receive one message for at most the given time interval and returns "
"``null`` in case of failure. If the given Duration is zero, the call is non-"
"blocking (polling mode)."
msgstr ""

# 26db0ddf957541628ea412bf68e18a7f
#: ../../scala/testing.rst:295
msgid ""
":meth:`receiveWhile[T](max: Duration, idle: Duration, messages: Int)(pf: "
"PartialFunction[Any, T]): Seq[T]`"
msgstr ""

# f58aa920eebf482b937147cf1efd8ccd
#: ../../scala/testing.rst:297
msgid "Collect messages as long as"
msgstr ""

# ffe967b4f8b44501a53862b53b290e19
#: ../../scala/testing.rst:299
msgid "they are matching the given partial function"
msgstr ""

# f5521ee9bfc54d68ba9ffe35830f3292
#: ../../scala/testing.rst:300
msgid "the given time interval is not used up"
msgstr ""

# 26a65b37b73e476f888fe382bec3c2bf
#: ../../scala/testing.rst:301
msgid "the next message is received within the idle timeout"
msgstr ""

# 015e8f8176ff40c8b2e44a6dc9e2559b
#: ../../scala/testing.rst:302
msgid "the number of messages has not yet reached the maximum"
msgstr ""

# 104db1e52d1244a3a924110261f34b25
#: ../../scala/testing.rst:304
msgid ""
"All collected messages are returned. The maximum duration defaults to the "
"time remaining in the innermost enclosing :ref:`within <TestKit.within>` "
"block and the idle duration defaults to infinity (thereby disabling the idle "
"timeout feature). The number of expected messages defaults to ``Int."
"MaxValue``, which effectively disables this limit."
msgstr ""

# 9097605da5b046eb8debfe639239c0d6
#: ../../scala/testing.rst:310
msgid ":meth:`awaitCond(p: => Boolean, max: Duration, interval: Duration)`"
msgstr ""

# cbb338ad721341df8122de367ddee585
#: ../../scala/testing.rst:312
msgid ""
"Poll the given condition every :obj:`interval` until it returns ``true`` or "
"the :obj:`max` duration is used up. The interval defaults to 100 ms and the "
"maximum defaults to the time remaining in the innermost enclosing :ref:"
"`within <TestKit.within>` block."
msgstr ""

# 273457a2e8e14b2987d03d4b7b5d570d
#: ../../scala/testing.rst:317
msgid ":meth:`ignoreMsg(pf: PartialFunction[AnyRef, Boolean])`"
msgstr ""

# 7c70d934e45c4e6da3a51923a9e0b97e
#: ../../scala/testing.rst:319
msgid ":meth:`ignoreNoMsg`"
msgstr ""

# b41ec59981f64673ac1c32b983dcb26d
#: ../../scala/testing.rst:321
msgid ""
"The internal :obj:`testActor` contains a partial function for ignoring "
"messages: it will only enqueue messages which do not match the function or "
"for which the function returns ``false``. This function can be set and reset "
"using the methods given above; each invocation replaces the previous "
"function, they are not composed."
msgstr ""

# a4efb3f85c3c422fb118ed9bc875bef2
#: ../../scala/testing.rst:327
msgid ""
"This feature is useful e.g. when testing a logging system, where you want to "
"ignore regular messages and are only interested in your specific ones."
msgstr ""

# 601d79965d8e480d9a0421381f836b88
#: ../../scala/testing.rst:333
msgid ""
"Since an integration test does not allow to the internal processing of the "
"participating actors, verifying expected exceptions cannot be done directly. "
"Instead, use the logging system for this purpose: replacing the normal event "
"handler with the :class:`TestEventListener` and using an :class:"
"`EventFilter` allows assertions on log messages, including those which are "
"generated by exceptions:"
msgstr ""

# 9cfd2415d1a64c539dc0219360760ee2
#: ../../scala/testing.rst:345
msgid "Timing Assertions"
msgstr ""

# 7a9294d9a280485dbad8598959800cbf
#: ../../scala/testing.rst:347
msgid ""
"Another important part of functional testing concerns timing: certain events "
"must not happen immediately (like a timer), others need to happen before a "
"deadline. Therefore, all examination methods accept an upper time limit "
"within the positive or negative result must be obtained. Lower time limits "
"need to be checked external to the examination, which is facilitated by a "
"new construct for managing time constraints:"
msgstr ""

# c9e54d08a7d44a8896d91e5625e7d27c
#: ../../scala/testing.rst:360
msgid ""
"The block given to :meth:`within` must complete after a :ref:`Duration` "
"which is between :obj:`min` and :obj:`max`, where the former defaults to "
"zero. The deadline calculated by adding the :obj:`max` parameter to the "
"block's start time is implicitly available within the block to all "
"examination methods, if you do not specify it, is is inherited from the "
"innermost enclosing :meth:`within` block."
msgstr ""

# c345be92311f40729d6b536ed05a32b4
#: ../../scala/testing.rst:367
msgid ""
"It should be noted that if the last message-receiving assertion of the block "
"is :meth:`expectNoMsg` or :meth:`receiveWhile`, the final check of the :meth:"
"`within` is skipped in order to avoid false positives due to wake-up "
"latencies. This means that while individual contained assertions still use "
"the maximum time bound, the overall block may take arbitrarily longer in "
"this case."
msgstr ""

# 7cecf1da1694484682bc01df1b23984f
#: ../../scala/testing.rst:377
msgid ""
"All times are measured using ``System.nanoTime``, meaning that they describe "
"wall time, not CPU time."
msgstr ""

# bd7b40fa68694ab594cfb24efa98b457
#: ../../scala/testing.rst:380
msgid ""
"Ray Roestenburg has written a great article on using the TestKit: `<http://"
"roestenburg.agilesquad.com/2011/02/unit-testing-akka-actors-with-testkit_12."
"html>`_. His full example is also available :ref:`here <testkit-example>`."
msgstr ""

# 06635b3867044a39bf9625004bbc3f64
#: ../../scala/testing.rst:385
msgid "Accounting for Slow Test Systems"
msgstr ""

# e74369fbf27449fcba79a7fd4961f8ae
#: ../../scala/testing.rst:387
msgid ""
"The tight timeouts you use during testing on your lightning-fast notebook "
"will invariably lead to spurious test failures on the heavily loaded Jenkins "
"server (or similar). To account for this situation, all maximum durations "
"are internally scaled by a factor taken from the :ref:`configuration`, "
"``akka.test.timefactor``, which defaults to 1."
msgstr ""

# 1f59f081810c41a1b76eb3a563330911
#: ../../scala/testing.rst:393
msgid ""
"You can scale other durations with the same factor by using the implicit "
"conversion in ``akka.testkit`` package object to add dilated function to :"
"class:`Duration`."
msgstr ""

# e4c96d295fe645bcb4511a2b130c5da4
#: ../../scala/testing.rst:399
msgid "Resolving Conflicts with Implicit ActorRef"
msgstr ""

# 9e510b04a229477c87cf95a1702dc0f9
#: ../../scala/testing.rst:401
msgid ""
"If you want the sender of messages inside your TestKit-based tests to be the "
"``testActor`` simply mix in ``ÌmplicitSender`` into your test."
msgstr ""

# ea0108470b544ed6a33d74c235fd40e6
#: ../../scala/testing.rst:407
msgid "Using Multiple Probe Actors"
msgstr ""

# 4c035ff0bd694f1aa0558d33ae961852
#: ../../scala/testing.rst:409
msgid ""
"When the actors under test are supposed to send various messages to "
"different destinations, it may be difficult distinguishing the message "
"streams arriving at the :obj:`testActor` when using the :class:`TestKit` as "
"a mixin. Another approach is to use it for creation of simple probe actors "
"to be inserted in the message flows. To make this more powerful and "
"convenient, there is a concrete implementation called :class:`TestProbe`. "
"The functionality is best explained using a small example:"
msgstr ""

# 10b08798e36a4192be14908bf6096e0e
#: ../../scala/testing.rst:420
msgid ""
"Here a the system under test is simulated by :class:`MyDoubleEcho`, which is "
"supposed to mirror its input to two outputs. Attaching two test probes "
"enables verification of the (simplistic) behavior. Another example would be "
"two actors A and B which collaborate by A sending messages to B. In order to "
"verify this message flow, a :class:`TestProbe` could be inserted as target "
"of A, using the forwarding capabilities or auto-pilot described below to "
"include a real B in the test setup."
msgstr ""

# bb57bc432e724914bb929e612419e2ea
#: ../../scala/testing.rst:428
msgid ""
"Probes may also be equipped with custom assertions to make your test code "
"even more concise and clear:"
msgstr ""

# fc9402b395014a9d8315d03d0f1c9e7f
#: ../../scala/testing.rst:434
msgid ""
"You have complete flexibility here in mixing and matching the :class:"
"`TestKit` facilities with your own checks and choosing an intuitive name for "
"it. In real life your code will probably be a bit more complicated than the "
"example given above; just use the power!"
msgstr ""

# 686495d03ad645a7995a406c35f7ca6c
#: ../../scala/testing.rst:440
msgid "Replying to Messages Received by Probes"
msgstr ""

# 85de89691ab94b858fbd3e2c8e477e4b
#: ../../scala/testing.rst:442
msgid ""
"The probes keep track of the communications channel for replies, if "
"possible, so they can also reply:"
msgstr ""

# 810f00342e1b48d08a3f7eda2180b9d5
#: ../../scala/testing.rst:448
msgid "Forwarding Messages Received by Probes"
msgstr ""

# 1e4ee2e1b10243d5bba38387de893c65
#: ../../scala/testing.rst:450
msgid ""
"Given a destination actor ``dest`` which in the nominal actor network would "
"receive a message from actor ``source``. If you arrange for the message to "
"be sent to a :class:`TestProbe` ``probe`` instead, you can make assertions "
"concerning volume and timing of the message flow while still keeping the "
"network functioning:"
msgstr ""

# 79a2e905976b4b95a485a358554eedd8
#: ../../scala/testing.rst:459
msgid ""
"The ``dest`` actor will receive the same message invocation as if no test "
"probe had intervened."
msgstr ""

# a51fb2c1a6984ea9b492d34542df7e7e
#: ../../scala/testing.rst:463
msgid "Auto-Pilot"
msgstr ""

# e59f9f5c1aec426683976affb430addb
#: ../../scala/testing.rst:465
msgid ""
"Receiving messages in a queue for later inspection is nice, but in order to "
"keep a test running and verify traces later you can also install an :class:"
"`AutoPilot` in the participating test probes (actually in any :class:"
"`TestKit`) which is invoked before enqueueing to the inspection queue. This "
"code can be used to forward messages, e.g. in a chain ``A --> Probe --> B``, "
"as long as a certain protocol is obeyed."
msgstr ""

# 74c71e3062b9465bb8c1631022d27ab1
#: ../../scala/testing.rst:474
msgid ""
"The :meth:`run` method must return the auto-pilot for the next message, "
"wrapped in an :class:`Option`; setting it to :obj:`None` terminates the auto-"
"pilot."
msgstr ""

# 87f65d7a9db244a492df3ccd1c2f6d53
#: ../../scala/testing.rst:478
msgid "Caution about Timing Assertions"
msgstr ""

# 9f4270504f0e430ca5a4a6d6eacde67c
#: ../../scala/testing.rst:480
msgid ""
"The behavior of :meth:`within` blocks when using test probes might be "
"perceived as counter-intuitive: you need to remember that the nicely scoped "
"deadline as described :ref:`above <TestKit.within>` is local to each probe. "
"Hence, probes do not react to each other's deadlines or to the deadline set "
"in an enclosing :class:`TestKit` instance::"
msgstr ""

# f912a24f530f4b5a98274fadcb41898e
#: ../../scala/testing.rst:495
msgid ""
"This test will hang indefinitely, because the :meth:`expectMsg` call does "
"not see any deadline. Currently, the only option is to use ``probe.within`` "
"in the above code to make it work; later versions may include lexically "
"scoped deadlines using implicit arguments."
msgstr ""

# 42cf60d400f34a138d575e6d8db0318f
#: ../../scala/testing.rst:503
msgid ""
"The :class:`CallingThreadDispatcher` serves good purposes in unit testing, "
"as described above, but originally it was conceived in order to allow "
"contiguous stack traces to be generated in case of an error. As this special "
"dispatcher runs everything which would normally be queued directly on the "
"current thread, the full history of a message's processing chain is recorded "
"on the call stack, so long as all intervening actors run on this dispatcher."
msgstr ""

# cd49bf58bdb04079becbc241f66bd232
#: ../../scala/testing.rst:511
msgid "How to use it"
msgstr ""

# 829b9709736a42388823ec274b99ffd8
#: ../../scala/testing.rst:513
msgid "Just set the dispatcher as you normally would:"
msgstr ""

# 4f5ca5624dd549c9a3d48e63a813513c
#: ../../scala/testing.rst:518
msgid "How it works"
msgstr ""

# 057a3d2f94774f6d920b740801f3d911
#: ../../scala/testing.rst:520
msgid ""
"When receiving an invocation, the :class:`CallingThreadDispatcher` checks "
"whether the receiving actor is already active on the current thread. The "
"simplest example for this situation is an actor which sends a message to "
"itself. In this case, processing cannot continue immediately as that would "
"violate the actor model, so the invocation is queued and will be processed "
"when the active invocation on that actor finishes its processing; thus, it "
"will be processed on the calling thread, but simply after the actor finishes "
"its previous work. In the other case, the invocation is simply processed "
"immediately on the current thread. Futures scheduled via this dispatcher are "
"also executed immediately."
msgstr ""

# ad2a839cd9bf401585b25c3ed706f269
#: ../../scala/testing.rst:531
msgid ""
"This scheme makes the :class:`CallingThreadDispatcher` work like a general "
"purpose dispatcher for any actors which never block on external events."
msgstr ""

# c2b821b5e46b4cb0b40c34191ac4c0bb
#: ../../scala/testing.rst:534
msgid ""
"In the presence of multiple threads it may happen that two invocations of an "
"actor running on this dispatcher happen on two different threads at the same "
"time. In this case, both will be processed directly on their respective "
"threads, where both compete for the actor's lock and the loser has to wait. "
"Thus, the actor model is left intact, but the price is loss of concurrency "
"due to limited scheduling. In a sense this is equivalent to traditional "
"mutex style concurrency."
msgstr ""

# 5fbccffdda33447e859dc6b1a2ac1e5e
#: ../../scala/testing.rst:542
msgid ""
"The other remaining difficulty is correct handling of suspend and resume: "
"when an actor is suspended, subsequent invocations will be queued in thread-"
"local queues (the same ones used for queuing in the normal case). The call "
"to :meth:`resume`, however, is done by one specific thread, and all other "
"threads in the system will probably not be executing this specific actor, "
"which leads to the problem that the thread-local queues cannot be emptied by "
"their native threads. Hence, the thread calling :meth:`resume` will collect "
"all currently queued invocations from all threads into its own queue and "
"process them."
msgstr ""

# 660764f0026b4c4fb786ac086c2f14ff
#: ../../scala/testing.rst:552
msgid "Limitations"
msgstr ""

# 2b35109eec2342ba8a6bcbc804160a24
#: ../../scala/testing.rst:554
msgid ""
"If an actor's behavior blocks on a something which would normally be "
"affected by the calling actor after having sent the message, this will "
"obviously dead-lock when using this dispatcher. This is a common scenario in "
"actor tests based on :class:`CountDownLatch` for synchronization:"
msgstr ""

# 3a92f23f62d147bc90c97b1f1aae664c
#: ../../scala/testing.rst:566
msgid ""
"The example would hang indefinitely within the message processing initiated "
"on the second line and never reach the fourth line, which would unblock it "
"on a normal dispatcher."
msgstr ""

# 88a76a0d931748cb9034c95fc4a3b226
#: ../../scala/testing.rst:570
msgid ""
"Thus, keep in mind that the :class:`CallingThreadDispatcher` is not a "
"general-purpose replacement for the normal dispatchers. On the other hand it "
"may be quite useful to run your actor network on it for testing, because if "
"it runs without dead-locking chances are very high that it will not dead-"
"lock in production."
msgstr ""

# 199bbfaa3eab4b6d9d7013eb4f23f505
#: ../../scala/testing.rst:578
msgid ""
"The above sentence is unfortunately not a strong guarantee, because your "
"code might directly or indirectly change its behavior when running on a "
"different dispatcher. If you are looking for a tool to help you debug dead-"
"locks, the :class:`CallingThreadDispatcher` may help with certain error "
"scenarios, but keep in mind that it has may give false negatives as well as "
"false positives."
msgstr ""

# 2bafc1d73d3d4ac5a689fefd1a301673
#: ../../scala/testing.rst:586
msgid "Benefits"
msgstr ""

# 3f741a369f504400bcf8e11971165cd8
#: ../../scala/testing.rst:588
msgid ""
"To summarize, these are the features with the :class:"
"`CallingThreadDispatcher` has to offer:"
msgstr ""

# 628e05dd06c14365929f3177695c6017
#: ../../scala/testing.rst:591
msgid ""
"Deterministic execution of single-threaded tests while retaining nearly full "
"actor semantics"
msgstr ""

# 3c6c05fac13d43abaf618a30c8131fdc
#: ../../scala/testing.rst:593
msgid ""
"Full message processing history leading up to the point of failure in "
"exception stack traces"
msgstr ""

# 5004715af0164a118521e433c4806991
#: ../../scala/testing.rst:595
msgid "Exclusion of certain classes of dead-lock scenarios"
msgstr ""

# 2073911e5de148389e2800f9d4e76651
#: ../../scala/testing.rst:600
msgid "Tracing Actor Invocations"
msgstr ""

# ca7105f142784c1fa2139d70461d0d24
#: ../../scala/testing.rst:602
msgid ""
"The testing facilities described up to this point were aiming at formulating "
"assertions about a system’s behavior. If a test fails, it is usually your "
"job to find the cause, fix it and verify the test again. This process is "
"supported by debuggers as well as logging, where the Akka toolkit offers the "
"following options:"
msgstr ""

# 7e70e0ae0bd447509af3abe869e90dc0
#: ../../scala/testing.rst:608
msgid "*Logging of exceptions thrown within Actor instances*"
msgstr ""

# 1e0bcaf7a93646d2808dd74b58676eb6
#: ../../scala/testing.rst:610
msgid ""
"This is always on; in contrast to the other logging mechanisms, this logs at "
"``ERROR`` level."
msgstr ""

# d2e2e5656283410a8af38a4246dabf41
#: ../../scala/testing.rst:613
msgid "*Logging of message invocations on certain actors*"
msgstr ""

# d0080ee9bd314f4597b88a6b3ac6d5dc
#: ../../scala/testing.rst:615
msgid ""
"This is enabled by a setting in the :ref:`configuration` — namely ``akka."
"actor.debug.receive`` — which enables the :meth:`loggable` statement to be "
"applied to an actor’s :meth:`receive` function:"
msgstr ""

# aaa4775b7a0442738f16667fef2e93b2
#: ../../scala/testing.rst:622
msgid ""
"If the abovementioned setting is not given in the :ref:`configuration`, this "
"method will pass through the given :class:`Receive` function unmodified, "
"meaning that there is no runtime cost unless actually enabled."
msgstr ""

# 925ce1bf41474b78bfed4841048ed2c8
#: ../../scala/testing.rst:626
msgid ""
"The logging feature is coupled to this specific local mark-up because "
"enabling it uniformly on all actors is not usually what you need, and it "
"would lead to endless loops if it were applied to :class:`EventHandler` "
"listeners."
msgstr ""

# 3d8a1e8f487f4d798b1663819e0bba77
#: ../../scala/testing.rst:631
msgid "*Logging of special messages*"
msgstr ""

# 03fe421a71fe4233a86c886f1f991f67
#: ../../scala/testing.rst:633
msgid ""
"Actors handle certain special messages automatically, e.g. :obj:`Kill`, :obj:"
"`PoisonPill`, etc. Tracing of these message invocations is enabled by the "
"setting ``akka.actor.debug.autoreceive``, which enables this on all actors."
msgstr ""

# 07c8a05f08b1444db1b80d3dd1980512
#: ../../scala/testing.rst:638
msgid "*Logging of the actor lifecycle*"
msgstr ""

# 308cab6488734657af3b34903cb69a0a
#: ../../scala/testing.rst:640
msgid ""
"Actor creation, start, restart, monitor start, monitor stop and stop may be "
"traced by enabling the setting ``akka.actor.debug.lifecycle``; this, too, is "
"enabled uniformly on all actors."
msgstr ""

# 54ce098f628744f190951f2ff22d7876
#: ../../scala/testing.rst:644
msgid ""
"All these messages are logged at ``DEBUG`` level. To summarize, you can "
"enable full logging of actor activities using this configuration fragment::"
msgstr ""

# af804166a2cf455fb8c381804dc0b8e7
#: ../../scala/testkit-example.rst:5
msgid "TestKit Example (Scala)"
msgstr ""

# 5701531a06b447b19900ae65c8cca4c3
#: ../../scala/testkit-example.rst:7
msgid ""
"Ray Roestenburg's example code from `his blog <http://roestenburg.agilesquad."
"com/2011/02/unit-testing-akka-actors-with-testkit_12.html>`_ adapted to work "
"with Akka 1.1."
msgstr ""

# b6b451191cda4f2cbaa91248d90d3643
#: ../../scala/transactors.rst:5
msgid "Transactors (Scala)"
msgstr ""

# c7c9dcf7a62d44b494c6f11abb6dd185
#: ../../scala/transactors.rst:9
msgid "Why Transactors?"
msgstr ""

# 4519813e0a8b425891e57bdcdbff591b
#: ../../scala/transactors.rst:11
msgid ""
"Actors are excellent for solving problems where you have many independent "
"processes that can work in isolation and only interact with other Actors "
"through message passing. This model fits many problems. But the actor model "
"is unfortunately a terrible model for implementing truly shared state. E.g. "
"when you need to have consensus and a stable view of state across many "
"components. The classic example is the bank account where clients can "
"deposit and withdraw, in which each operation needs to be atomic. For "
"detailed discussion on the topic see `this JavaOne presentation <http://www."
"slideshare.net/jboner/state-youre-doing-it-wrong-javaone-2009>`_."
msgstr ""

# c3bf5c00cd3d46f6ac000a4fd8b65732
#: ../../scala/transactors.rst:21
msgid ""
"STM on the other hand is excellent for problems where you need consensus and "
"a stable view of the state by providing compositional transactional shared "
"state. Some of the really nice traits of STM are that transactions compose, "
"and it raises the abstraction level from lock-based concurrency."
msgstr ""

# dc2f1d1d29f946a1b8235939c6b21259
#: ../../scala/transactors.rst:26
msgid ""
"Akka's Transactors combine Actors and STM to provide the best of the Actor "
"model (concurrency and asynchronous event-based programming) and STM "
"(compositional transactional shared state) by providing transactional, "
"compositional, asynchronous, event-based message flows."
msgstr ""

# f64c53c4bee94e0e8e8bdce296f45928
#: ../../scala/transactors.rst:34
msgid ""
"When you really need composable message flows across many actors updating "
"their **internal local** state but need them to do that atomically in one "
"big transaction. Might not be often but when you do need this then you are "
"screwed without it."
msgstr ""

# b5b0aa4b8c954c4ba2aefb257a24619b
#: ../../scala/transactors.rst:43
msgid "Actors and STM"
msgstr ""

# 918b3c643975478ab7839aaa8e599b29
#: ../../scala/transactors.rst:45
msgid ""
"You can combine Actors and STM in several ways. An Actor may use STM "
"internally so that particular changes are guaranteed to be atomic. Actors "
"may also share transactional datastructures as the STM provides safe shared "
"state across threads."
msgstr ""

# 08bbf31c8e624cceaf7a0ddd50ce615b
#: ../../scala/transactors.rst:50
msgid ""
"It's also possible to coordinate transactions across Actors or threads so "
"that either the transactions in a set all commit successfully or they all "
"fail. This is the focus of Transactors and the explicit support for "
"coordinated transactions in this section."
msgstr ""

# f775eafb1d6a4a38adfc57bd0751c13a
#: ../../scala/transactors.rst:57
msgid "Coordinated transactions"
msgstr ""

# 3d541075acee40d8a789ea58a90435af
#: ../../scala/transactors.rst:59
msgid ""
"Akka provides an explicit mechanism for coordinating transactions across "
"Actors. Under the hood it uses a ``CommitBarrier``, similar to a "
"CountDownLatch."
msgstr ""

# 52a32cefe2654e4f8a44d276c63c0f85
#: ../../scala/transactors.rst:62
msgid ""
"Here is an example of coordinating two simple counter Actors so that they "
"both increment together in coordinated transactions. If one of them was to "
"fail to increment, the other would also fail."
msgstr ""

# 6e7777381c9341e6851e5a37a512bbf8
#: ../../scala/transactors.rst:70
msgid ""
"Note that creating a ``Coordinated`` object requires a ``Timeout`` to be "
"specified for the coordinated transaction. This can be done implicitly, by "
"having an implicit ``Timeout`` in scope, or explicitly, by passing the "
"timeout when creating a a ``Coordinated`` object. Here's an example of "
"specifying an implicit timeout:"
msgstr ""

# bff6d50acaef4198860bd1ebc3e6146f
#: ../../scala/transactors.rst:78
msgid ""
"To start a new coordinated transaction that you will also participate in, "
"just create a ``Coordinated`` object (this assumes an implicit timeout):"
msgstr ""

# efece755742e40098034e3219bbbbdd5
#: ../../scala/transactors.rst:83
msgid ""
"To start a coordinated transaction that you won't participate in yourself "
"you can create a ``Coordinated`` object with a message and send it directly "
"to an actor. The recipient of the message will be the first member of the "
"coordination set:"
msgstr ""

# 715e1fda6c1e416db784f54a79a0787a
#: ../../scala/transactors.rst:90
msgid ""
"To receive a coordinated message in an actor simply match it in a case "
"statement:"
msgstr ""

# 7ca799429cc24c7f9a210f07fa3b8610
#: ../../scala/transactors.rst:96
msgid ""
"To include another actor in the same coordinated transaction that you've "
"created or received, use the apply method on that object. This will "
"increment the number of parties involved by one and create a new "
"``Coordinated`` object to be sent."
msgstr ""

# a652cacf39ff40219c9e13b7746d1b3b
#: ../../scala/transactors.rst:102
msgid ""
"To enter the coordinated transaction use the atomic method of the "
"coordinated object:"
msgstr ""

# 156f700c6e3a475d95a7af8fc6199c3f
#: ../../scala/transactors.rst:107
msgid ""
"The coordinated transaction will wait for the other transactions before "
"committing. If any of the coordinated transactions fail then they all fail."
msgstr ""

# f2d5ca9a84f548c49eecdb302f0548ca
#: ../../scala/transactors.rst:112
msgid ""
"The same actor should not be added to a coordinated transaction more than "
"once. The transaction will not be able to complete as an actor only "
"processes a single message at a time. When processing the first message the "
"coordinated transaction will wait for the commit barrier, which in turn "
"needs the second message to be received to proceed."
msgstr ""

# 81a0f09d6ada47c296910af3bf33d356
#: ../../scala/transactors.rst:120
msgid "Transactor"
msgstr ""

# afea148621e84278b329427806ba4c9a
#: ../../scala/transactors.rst:122
msgid ""
"Transactors are actors that provide a general pattern for coordinating "
"transactions, using the explicit coordination described above."
msgstr ""

# d289c3b597784607a1748c9184c86828
#: ../../scala/transactors.rst:125
msgid ""
"Here's an example of a simple transactor that will join a coordinated "
"transaction:"
msgstr ""

# 52066fe8ffc7431c8e5d51d29555c4ff
#: ../../scala/transactors.rst:130
msgid ""
"You could send this Counter transactor a ``Coordinated(Increment)`` message. "
"If you were to send it just an ``Increment`` message it will create its own "
"``Coordinated`` (but in this particular case wouldn't be coordinating "
"transactions with any other transactors)."
msgstr ""

# 91dca087fcb8414c8c2ca03dd74d9672
#: ../../scala/transactors.rst:135
msgid ""
"To coordinate with other transactors override the ``coordinate`` method. The "
"``coordinate`` method maps a message to a set of ``SendTo`` objects, pairs "
"of ``ActorRef`` and a message. You can use the ``include`` and ``sendTo`` "
"methods to easily coordinate with other transactors. The ``include`` method "
"will send on the same message that was received to other transactors. The "
"``sendTo`` method allows you to specify both the actor to send to, and the "
"message to send."
msgstr ""

# 22a25e3ab1be4491a6184d3cd9332a82
#: ../../scala/transactors.rst:142
msgid "Example of coordinating an increment:"
msgstr ""

# a1301affe9df447ea94a1bbec2ccfb5b
#: ../../scala/transactors.rst:146
msgid "Using ``include`` to include more than one transactor:"
msgstr ""

# 844a2ca628b64748a76aa2938d720b63
#: ../../scala/transactors.rst:150
msgid ""
"Using ``sendTo`` to coordinate transactions but pass-on a different message "
"than the one that was received:"
msgstr ""

# d98b9124ed004e1e8dfe412256535da7
#: ../../scala/transactors.rst:155
msgid ""
"To execute directly before or after the coordinated transaction, override "
"the ``before`` and ``after`` methods. These methods also expect partial "
"functions like the receive method. They do not execute within the "
"transaction."
msgstr ""

# 9ceafcdc830545e2b5866e841fc9f393
#: ../../scala/transactors.rst:159
msgid ""
"To completely bypass coordinated transactions override the ``normally`` "
"method. Any message matched by ``normally`` will not be matched by the other "
"methods, and will not be involved in coordinated transactions. In this "
"method you can implement normal actor behavior, or use the normal STM atomic "
"for local transactions."
msgstr ""

# 6ffaa709404e4b41b44d9d527adc6b2e
#: ../../scala/typed-actors.rst:2
msgid "Typed Actors (Scala)"
msgstr ""

# d40a7bbe2ec1493a828546fbf9363ebe
#: ../../scala/typed-actors.rst:4
msgid ""
"Akka Typed Actors is an implementation of the `Active Objects <http://en."
"wikipedia.org/wiki/Active_object>`_ pattern. Essentially turning method "
"invocations into asynchronous dispatch instead of synchronous that has been "
"the default way since Smalltalk came out."
msgstr ""

# eb8e131040214d0594d3a71e5f31dd24
#: ../../scala/typed-actors.rst:7
msgid ""
"Typed Actors consist of 2 \"parts\", a public interface and an "
"implementation, and if you've done any work in \"enterprise\" Java, this "
"will be very familiar to you. As with normal Actors you have an external API "
"(the public interface instance) that will delegate methodcalls "
"asynchronously to a private instance of the implementation."
msgstr ""

# 56f77b3385934fc580fd9c7d182c070a
#: ../../scala/typed-actors.rst:10
msgid ""
"The advantage of Typed Actors vs. Actors is that with TypedActors you have a "
"static contract, and don't need to define your own messages, the downside is "
"that it places some limitations on what you can do and what you can't, i.e. "
"you can't use become/unbecome."
msgstr ""

# ba39605ea5a249f0b7f9d61a9ec09e97
#: ../../scala/typed-actors.rst:12
msgid ""
"Typed Actors are implemented using `JDK Proxies <http://docs.oracle.com/"
"javase/6/docs/api/java/lang/reflect/Proxy.html>`_ which provide a pretty "
"easy-worked API to intercept method calls."
msgstr ""

# 1725a21122f0443cb2849a77f1bc22fb
#: ../../scala/typed-actors.rst:16
msgid ""
"Just as with regular Akka Actors, Typed Actors process one call at a time."
msgstr ""

# 3d455df66a6d4453a711ee584c5f2e74
#: ../../scala/typed-actors.rst:19
msgid "When to use Typed Actors"
msgstr ""

# d3952e3f1eed487595edec7f707779b7
#: ../../scala/typed-actors.rst:21
msgid ""
"Typed actors are nice for bridging between actor systems (the “inside”) and "
"non-actor code (the “outside”), because they allow you to write normal OO-"
"looking code on the outside. Think of them like doors: their practicality "
"lies in interfacing between private sphere and the public, but you don’t "
"want that many doors inside your house, do you? For a longer discussion see "
"`this blog post <http://letitcrash.com/post/19074284309/when-to-use-"
"typedactors>`_."
msgstr ""

# c98a081ab7da48d6899404c17a88380b
#: ../../scala/typed-actors.rst:28
msgid ""
"A bit more background: TypedActors can very easily be abused as RPC, and "
"that is an abstraction which is `well-known <http://labs.oracle.com/"
"techrep/1994/abstract-29.html>`_ to be leaky. Hence TypedActors are not what "
"we think of first when we talk about making highly scalable concurrent "
"software easier to write correctly. They have their niche, use them "
"sparingly."
msgstr ""

# cc12935aeef74d2da50a836d3de3675b
#: ../../scala/typed-actors.rst:36
msgid "The tools of the trade"
msgstr ""

# b5acfb1f1f144d00a364f51d3e7c9e8a
#: ../../scala/typed-actors.rst:38
msgid ""
"Before we create our first Typed Actor we should first go through the tools "
"that we have at our disposal, it's located in ``akka.actor.TypedActor``."
msgstr ""

# f78edc2a7e4f4710a33961e11e9ae615
#: ../../scala/typed-actors.rst:46
msgid ""
"Same as not exposing ``this`` of an Akka Actor, it's important not to expose "
"``this`` of a Typed Actor, instead you should pass the external proxy "
"reference, which is obtained from within your Typed Actor as ``TypedActor."
"self``, this is your external identity, as the ``ActorRef`` is the external "
"identity of an Akka Actor."
msgstr ""

# 7ee33fa2ba274478ac946cd500ddca4b
#: ../../scala/typed-actors.rst:52
msgid "Creating Typed Actors"
msgstr ""

# 967593b80e5846d7958481fbaf85fb86
#: ../../scala/typed-actors.rst:54
msgid ""
"To create a Typed Actor you need to have one or more interfaces, and one "
"implementation."
msgstr ""

# 199e20ea06d144b6b8416e0122ed5a30
#: ../../scala/typed-actors.rst:56
msgid "Our example interface:"
msgstr ""

# ad002512fb7b47daa0d7cf88893eb86c
#: ../../scala/typed-actors.rst:62
msgid "Our example implementation of that interface:"
msgstr ""

# ff3c0d0020be43e39088e5a853e9b1f7
#: ../../scala/typed-actors.rst:68
msgid "The most trivial way of creating a Typed Actor instance of our Squarer:"
msgstr ""

# 1b80e5f0f34f4fba81314d8ed3a60862
#: ../../scala/typed-actors.rst:74
msgid ""
"First type is the type of the proxy, the second type is the type of the "
"implementation. If you need to call a specific constructor you do it like "
"this:"
msgstr ""

# c693877d718e4226bb6b4d330222105b
#: ../../scala/typed-actors.rst:80
msgid ""
"Since you supply a Props, you can specify which dispatcher to use, what the "
"default timeout should be used and more. Now, our Squarer doesn't have any "
"methods, so we'd better add those."
msgstr ""

# 57178898efae4005808e5a918a89dbcf
#: ../../scala/typed-actors.rst:86
msgid ""
"Alright, now we've got some methods we can call, but we need to implement "
"those in SquarerImpl."
msgstr ""

# 41b612152d764a37b0c360611f437079
#: ../../scala/typed-actors.rst:91
msgid ""
"Excellent, now we have an interface and an implementation of that interface, "
"and we know how to create a Typed Actor from that, so let's look at calling "
"these methods."
msgstr ""

# 0d63a2a8cb384c31a9aff9fe83aa925a
#: ../../scala/typed-actors.rst:95
msgid "Method dispatch semantics"
msgstr ""

# c9f2baa1dddc47beafef723a3c2411b0
#: ../../scala/typed-actors.rst:97
msgid "Methods returning:"
msgstr ""

# 37f2f5f650f64ae9a9f0ecf2bcfcd553
#: ../../scala/typed-actors.rst:99
msgid ""
"``Unit`` will be dispatched with ``fire-and-forget`` semantics, exactly like "
"``ActorRef.tell``"
msgstr ""

# 1dd246581ee84b968560ef8f22c61d4c
#: ../../scala/typed-actors.rst:100
msgid ""
"``akka.dispatch.Future[_]`` will use ``send-request-reply`` semantics, "
"exactly like ``ActorRef.ask``"
msgstr ""

# d5437201e8344a95b26ee1df214f4df5
#: ../../scala/typed-actors.rst:101
msgid ""
"``scala.Option[_]`` or ``akka.japi.Option<?>`` will use ``send-request-"
"reply`` semantics, but *will* block to wait for an answer, and return None "
"if no answer was produced within the timout, or scala.Some/akka.japi.Some "
"containing the result otherwise. Any exception that was thrown during this "
"call will be rethrown."
msgstr ""

# 01585ca4eb2e44ab98f3553a74f116ed
#: ../../scala/typed-actors.rst:104
msgid ""
"Any other type of value will use ``send-request-reply`` semantics, but "
"*will* block to wait for an answer, throwing ``java.util.concurrent."
"TimeoutException`` if there was a timeout or rethrow any exception that was "
"thrown during this call."
msgstr ""

# 36fee78d5b0f4ed99562e17a8845cde5
#: ../../scala/typed-actors.rst:110
msgid ""
"While Akka cannot enforce that the parameters to the methods of your Typed "
"Actors are immutable, we *strongly* recommend that parameters passed are "
"immutable."
msgstr ""

# 7f60500939cc4bc8bad31ab9c538946b
#: ../../scala/typed-actors.rst:114
msgid "One-way message send"
msgstr ""

# 928029cce14d437ea0058fdeae2ea49c
#: ../../scala/typed-actors.rst:119
msgid ""
"As simple as that! The method will be executed on another thread; "
"asynchronously."
msgstr ""

# e43d4862559a475796375e602266284a
#: ../../scala/typed-actors.rst:122
msgid "Request-reply message send"
msgstr ""

# 1dff882578874063a210978cdded83e9
#: ../../scala/typed-actors.rst:127
msgid ""
"This will block for as long as the timeout that was set in the Props of the "
"Typed Actor, if needed. It will return ``None`` if a timeout occurs."
msgstr ""

# 6058dc2e0809408c8ad4a89442fbdf00
#: ../../scala/typed-actors.rst:133
msgid ""
"This will block for as long as the timeout that was set in the Props of the "
"Typed Actor, if needed. It will throw a ``java.util.concurrent."
"TimeoutException`` if a timeout occurs."
msgstr ""

# 63e562d57598413089cb0eff3381c068
#: ../../scala/typed-actors.rst:137
msgid "Request-reply-with-future message send"
msgstr ""

# 5ff2c7acaabf470f8f11105403c8b0dc
#: ../../scala/typed-actors.rst:142
msgid ""
"This call is asynchronous, and the Future returned can be used for "
"asynchronous composition."
msgstr ""

# 6ed92ba24e9f449f8850128785a3b466
#: ../../scala/typed-actors.rst:145
msgid "Stopping Typed Actors"
msgstr ""

# 38c4dc18642c4b2cb61f7439ade9d4bc
#: ../../scala/typed-actors.rst:147
msgid ""
"Since Akkas Typed Actors are backed by Akka Actors they must be stopped when "
"they aren't needed anymore."
msgstr ""

# a05d30f45cc84f99a811e0ced1a87807
#: ../../scala/typed-actors.rst:152
msgid ""
"This asynchronously stops the Typed Actor associated with the specified "
"proxy ASAP."
msgstr ""

# c1494179b9cf4f2b9b8b26afa5de0aa9
#: ../../scala/typed-actors.rst:157
msgid ""
"This asynchronously stops the Typed Actor associated with the specified "
"proxy after it's done with all calls that were made prior to this call."
msgstr ""

# 388eb3b56bf04586a735663ce5993d15
#: ../../scala/typed-actors.rst:161
msgid "Typed Actor Hierarchies"
msgstr ""

# 79821600aae34ca9aa91fd5e84af1a3f
#: ../../scala/typed-actors.rst:163
msgid ""
"Since you can obtain a contextual Typed Actor Extension by passing in an "
"``ActorContext`` you can create child Typed Actors by invoking ``typedActorOf"
"(..)`` on that."
msgstr ""

# 5322a62a6c0a41d5ad81149724729f44
#: ../../scala/typed-actors.rst:166
msgid "This also works for creating child Typed Actors in regular Akka Actors."
msgstr ""

# f77738a82fda4facb7c9eeab6931c938
#: ../../scala/typed-actors.rst:169
msgid "Supervisor Strategy"
msgstr ""

# 7fd92ba32baa477191a099d989c29d07
#: ../../scala/typed-actors.rst:171
msgid ""
"By having your Typed Actor implementation class implement ``TypedActor."
"Supervisor`` you can define the strategy to use for supervising child "
"actors, as described in :ref:`supervision` and :ref:`fault-tolerance-scala`."
msgstr ""

# 74f3b68b69904866a49844d2ec0e64d5
#: ../../scala/typed-actors.rst:176
msgid "Lifecycle callbacks"
msgstr ""

# 0633f4994c3740548f16f1c73a85cfed
#: ../../scala/typed-actors.rst:178
msgid ""
"By having your Typed Actor implementation class implement any and all of the "
"following:"
msgstr ""

# 873bc8faf5664b33a59bac19a824971c
#: ../../scala/typed-actors.rst:180
msgid "``TypedActor.PreStart``"
msgstr ""

# 0d15b666b1624e3c9efe981cd53cecd3
#: ../../scala/typed-actors.rst:181
msgid "``TypedActor.PostStop``"
msgstr ""

# f9ef53936a1441098d12b9f05dd02444
#: ../../scala/typed-actors.rst:182
msgid "``TypedActor.PreRestart``"
msgstr ""

# 5c3c665c486941728f6d13a1eebed4c9
#: ../../scala/typed-actors.rst:183
msgid "``TypedActor.PostRestart``"
msgstr ""

# 8b5a336404aa412287568b7393c9198e
#: ../../scala/typed-actors.rst:185
msgid "You can hook into the lifecycle of your Typed Actor."
msgstr ""

# b17ed8c1c92c4043a653a07786dde834
#: ../../scala/typed-actors.rst:188
msgid "Receive arbitrary messages"
msgstr ""

# 738eacf4605143809c2207a12c349c37
#: ../../scala/typed-actors.rst:190
msgid ""
"If your implementation class of your TypedActor extends ``akka.actor."
"TypedActor.Receiver``, all messages that are not ``MethodCall``s will be "
"passed into the ``onReceive``-method."
msgstr ""

# 5678b63f2b2d4c4e86dc2829a89c5cd1
#: ../../scala/typed-actors.rst:193
msgid ""
"This allows you to react to DeathWatch ``Terminated``-messages and other "
"types of messages, e.g. when interfacing with untyped actors."
msgstr ""

# 9fde66d920d94d228e372b0f674048f7
#: ../../scala/typed-actors.rst:197
msgid "Proxying"
msgstr ""

# e8af5d6141df44f6a4458a19aa296baa
#: ../../scala/typed-actors.rst:199
msgid ""
"You can use the ``typedActorOf`` that takes a TypedProps and an ActorRef to "
"proxy the given ActorRef as a TypedActor. This is usable if you want to "
"communicate remotely with TypedActors on other machines, just look them up "
"with ``actorFor`` and pass the ``ActorRef`` to ``typedActorOf``."
msgstr ""

# e28dce5f50c341f2ab6f678a6a3f2196
#: ../../scala/typed-actors.rst:204
msgid "The ActorRef needs to accept ``MethodCall`` messages."
msgstr ""

# 2799211ffca44f308fab530507a88ade
#: ../../scala/typed-actors.rst:207
msgid "Supercharging"
msgstr ""

# a65ff7d4287c46f493ad65ed83fa1a93
#: ../../scala/typed-actors.rst:209
msgid ""
"Here's an example on how you can use traits to mix in behavior in your Typed "
"Actors."
msgstr ""

# 0d87999735a64162bc891c4b4c9e57cb
#: ../../scala/zeromq.rst:6
msgid "ZeroMQ (Scala)"
msgstr ""

# b9af7bf016b24dbf8cede16500fe2209
#: ../../scala/zeromq.rst:9
msgid ""
"Akka provides a ZeroMQ module which abstracts a ZeroMQ connection and "
"therefore allows interaction between Akka actors to take place over ZeroMQ "
"connections. The messages can be of a proprietary format or they can be "
"defined using Protobuf. The socket actor is fault-tolerant by default and "
"when you use the newSocket method to create new sockets it will properly "
"reinitialize the socket."
msgstr ""

# c52052827db34b2ebf0626fd617c6f83
#: ../../scala/zeromq.rst:11
msgid ""
"ZeroMQ is very opinionated when it comes to multi-threading so configuration "
"option `akka.zeromq.socket-dispatcher` always needs to be configured to a "
"PinnedDispatcher, because the actual ZeroMQ socket can only be accessed by "
"the thread that created it."
msgstr ""

# a2b931e279bf485b946f90230018bcce
#: ../../scala/zeromq.rst:13
msgid ""
"The ZeroMQ module for Akka is written against an API introduced in JZMQ, "
"which uses JNI to interact with the native ZeroMQ library. Instead of using "
"JZMQ, the module uses ZeroMQ binding for Scala that uses the native ZeroMQ "
"library through JNA. In other words, the only native library that this "
"module requires is the native ZeroMQ library. The benefit of the scala "
"library is that you don't need to compile and manage native dependencies at "
"the cost of some runtime performance. The scala-bindings are compatible with "
"the JNI bindings so they are a drop-in replacement, in case you really need "
"to get that extra bit of performance out."
msgstr ""

# 1bdcb0c49bbf49ceb2453baef3f648d6
#: ../../scala/zeromq.rst:17
msgid "Connection"
msgstr ""

# ca4de583f45a45b6bc55e1cc21fd9cf5
#: ../../scala/zeromq.rst:19
msgid ""
"ZeroMQ supports multiple connectivity patterns, each aimed to meet a "
"different set of requirements. Currently, this module supports publisher-"
"subscriber connections and connections based on dealers and routers. For "
"connecting or accepting connections, a socket must be created. Sockets are "
"always created using the ``akka.zeromq.ZeroMQExtension``, for example:"
msgstr ""

# ad07f5b18a4f47208807700f429601ab
#: ../../scala/zeromq.rst:24
msgid ""
"or by importing the ``akka.zeromq._`` package to make newSocket method "
"available on system, via an implicit conversion."
msgstr ""

# 87ef526ac52643b2a3a893d949085a4a
#: ../../scala/zeromq.rst:29
msgid ""
"Above examples will create a ZeroMQ Publisher socket that is Bound to the "
"port 1234 on localhost."
msgstr ""

# 75921240dc4c4aa790aa64526c540e07
#: ../../scala/zeromq.rst:31
msgid ""
"Similarly you can create a subscription socket, with a listener, that "
"subscribes to all messages from the publisher using:"
msgstr ""

# 58353b34f3c94632b21ac7e3901ee166
#: ../../scala/zeromq.rst:35
msgid ""
"The following sub-sections describe the supported connection patterns and "
"how they can be used in an Akka environment. However, for a comprehensive "
"discussion of connection patterns, please refer to `ZeroMQ -- The Guide "
"<http://zguide.zeromq.org/page:all>`_."
msgstr ""

# 3ffd55c449074aebb3dc9f6e3176affc
#: ../../scala/zeromq.rst:38
msgid "Publisher-Subscriber Connection"
msgstr ""

# 2e127c63f4ac418da24698c53c37997d
#: ../../scala/zeromq.rst:40
msgid ""
"In a publisher-subscriber (pub-sub) connection, the publisher accepts one or "
"more subscribers. Each subscriber shall subscribe to one or more topics, "
"whereas the publisher publishes messages to a set of topics. Also, a "
"subscriber can subscribe to all available topics. In an Akka environment, "
"pub-sub connections shall be used when an actor sends messages to one or "
"more actors that do not interact with the actor that sent the message."
msgstr ""

# beda618887084d1ba229e0c26a569702
#: ../../scala/zeromq.rst:45
msgid ""
"When you're using zeromq pub/sub you should be aware that it needs multicast "
"- check your cloud - to work properly and that the filtering of events for "
"topics happens client side, so all events are always broadcasted to every "
"subscriber."
msgstr ""

# 64283098776d4ccb8a23c4fd401852a1
#: ../../scala/zeromq.rst:47
msgid "An actor is subscribed to a topic as follows:"
msgstr ""

# 05c63d85096542898121b2c594c264bb
#: ../../scala/zeromq.rst:51
msgid ""
"It is a prefix match so it is subscribed to all topics starting with ``foo."
"bar``. Note that if the given string is empty or ``SubscribeAll`` is used, "
"the actor is subscribed to all topics."
msgstr ""

# 23cda5390eb64ac6a52e45d028124f6a
#: ../../scala/zeromq.rst:54
msgid "To unsubscribe from a topic you do the following:"
msgstr ""

# 683a5457036940ac812ba68cdf2d540d
#: ../../scala/zeromq.rst:58
msgid ""
"To publish messages to a topic you must use two Frames with the topic in the "
"first frame."
msgstr ""

# c51eea8de07f42b58ec25b83dbe26f7d
#: ../../scala/zeromq.rst:63
msgid "Pub-Sub in Action"
msgstr ""

# e5cc0b17b0c3428db379bac11f682d38
#: ../../scala/zeromq.rst:65
msgid "The following example illustrates one publisher with two subscribers."
msgstr ""

# 40513d4525894c6096337fcdac45f49f
#: ../../scala/zeromq.rst:67
msgid ""
"The publisher monitors current heap usage and system load and periodically "
"publishes ``Heap`` events on the ``\"health.heap\"`` topic and ``Load`` "
"events on the ``\"health.load\"`` topic."
msgstr ""

# 1948a6e14a7243608f8633129544ae20
#: ../../scala/zeromq.rst:72
msgid ""
"Let's add one subscriber that logs the information. It subscribes to all "
"topics starting with ``\"health\"``, i.e. both ``Heap`` and ``Load`` events."
msgstr ""

# f6b26231609a45ada5fa3f6d34144d33
#: ../../scala/zeromq.rst:77
msgid ""
"Another subscriber keep track of used heap and warns if too much heap is "
"used. It only subscribes to ``Heap`` events."
msgstr ""

# 81c0f5e86b3d4566a43b49d3b7d76377
#: ../../scala/zeromq.rst:82
msgid "Router-Dealer Connection"
msgstr ""

# 74ad370434e44c31953bf87f8b783c30
#: ../../scala/zeromq.rst:84
msgid ""
"While Pub/Sub is nice the real advantage of zeromq is that it is a \"lego-box"
"\" for reliable messaging. And because there are so many integrations the "
"multi-language support is fantastic. When you're using ZeroMQ to integrate "
"many systems you'll probably need to build your own ZeroMQ devices. This is "
"where the router and dealer socket types come in handy. With those socket "
"types you can build your own reliable pub sub broker that uses TCP/IP and "
"does publisher side filtering of events."
msgstr ""

# 17af86b6e49a4d6cb1dbdb71494ae9b5
#: ../../scala/zeromq.rst:88
msgid ""
"To create a Router socket that has a high watermark configured, you would do:"
msgstr ""

# fc12993a79994063b3011adb2a75b976
#: ../../scala/zeromq.rst:92
msgid ""
"The akka-zeromq module accepts most if not all the available configuration "
"options for a zeromq socket."
msgstr ""

# d0de9616826b40459b9b862725cfada2
#: ../../scala/zeromq.rst:95
msgid "Push-Pull Connection"
msgstr ""

# 4791b5b0713e4b369e71792322ce39b5
#: ../../scala/zeromq.rst:97
msgid "Akka ZeroMQ module supports ``Push-Pull`` connections."
msgstr ""

# fe50cd37f5a54474bd5e93a4ad422dde
#: ../../scala/zeromq.rst:99
msgid "You can create a ``Push`` connection through the::"
msgstr ""

# afbc5dd78b844d61949ed821195ec422
#: ../../scala/zeromq.rst:103
msgid "You can create a ``Pull`` connection through the::"
msgstr ""

# 9cfd3e069f844666abaa8d3b666bc23f
# 5f69dd02cc3e461db3c1fc1eebab4046
#: ../../scala/zeromq.rst:107 ../../scala/zeromq.rst:122
msgid "More documentation and examples will follow soon."
msgstr ""

# 1f63b2648121424ea1738b5b49433fb4
#: ../../scala/zeromq.rst:110
msgid "Rep-Req Connection"
msgstr ""

# ce3df42ec67b4351a36405645b9c7307
#: ../../scala/zeromq.rst:112
msgid "Akka ZeroMQ module supports ``Rep-Req`` connections."
msgstr ""

# 8dddd3aad2a74ee38a623900378fc034
#: ../../scala/zeromq.rst:114
msgid "You can create a ``Rep`` connection through the::"
msgstr ""

# 7089bd8c379645acb884f754b6c45dc8
#: ../../scala/zeromq.rst:118
msgid "You can create a ``Req`` connection through the::"
msgstr ""
